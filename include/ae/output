#include <iomanip>
#include <string>

//------------------------------------------------------------------------------
// aePlatform.h
// Platform specific defines
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEPLATFORM_H
#define AEPLATFORM_H

//------------------------------------------------------------------------------
// Platform defines
//------------------------------------------------------------------------------
#define _AE_IOS_ 0
#define _AE_OSX_ 0
#define _AE_APPLE_ 0
#define _AE_WINDOWS_ 0
#define _AE_LINUX_ 0
#define _AE_EMSCRIPTEN_ 0

#ifdef __EMSCRIPTEN__
  #undef _AE_EMSCRIPTEN_
  #define _AE_EMSCRIPTEN_ 1
#elif defined(__APPLE__)
  #include "TargetConditionals.h"
  #if TARGET_OS_IPHONE
    #undef _AE_IOS_
    #define _AE_IOS_ 1
  #elif TARGET_OS_MAC
    #undef _AE_OSX_
    #define _AE_OSX_ 1
  #else
    #error "Platform not supported"
  #endif
  #undef _AE_APPLE_
  #define _AE_APPLE_ 1
#elif defined(_MSC_VER)
  #undef _AE_WINDOWS_
  #define _AE_WINDOWS_ 1
#elif defined(__linux__)
  #undef _AE_LINUX_
  #define _AE_LINUX_ 1
#else
  #error "Platform not supported"
#endif

//------------------------------------------------------------------------------
// Debug define
//------------------------------------------------------------------------------
#if defined(_DEBUG) || defined(DEBUG) || ( _AE_APPLE_ && !defined(NDEBUG) )
  #define _AE_DEBUG_ 1
#else
  #define _AE_DEBUG_ 0
#endif

//------------------------------------------------------------------------------
// Warnings
//------------------------------------------------------------------------------
#if _AE_WINDOWS_
  #ifndef _CRT_SECURE_NO_WARNINGS
    #define _CRT_SECURE_NO_WARNINGS
  #endif
  #pragma warning( disable : 4244 )
  #pragma warning( disable : 4800 )
#endif

#if _AE_APPLE_
#define GL_SILENCE_DEPRECATION
#endif

#define AE_NAMESPACE ae

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------
#include <algorithm>
#include <cassert>
#include <chrono>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <sstream>
#include <functional>
#include <ostream>
#include <type_traits>
#include <typeinfo>
#include <utility>

//------------------------------------------------------------------------------
// Utils
//------------------------------------------------------------------------------
#if _AE_WINDOWS_
  #define aeAssert() __debugbreak()
#elif _AE_APPLE_
  #define aeAssert() __builtin_trap()
#elif _AE_EMSCRIPTEN_
  // @TODO: Handle asserts with emscripten builds
  #define aeAssert()
#else
  #define aeAssert() asm( "int $3" )
#endif

#if _AE_WINDOWS_
  #define aeCompilationWarning( _msg ) _Pragma( message _msg )
#else
  #define aeCompilationWarning( _msg ) _Pragma( "warning #_msg" )
#endif

#if _AE_LINUX_
  #define AE_ALIGN( _x ) __attribute__ ((aligned(_x)))
//#elif _AE_WINDOWS_
  //#define AE_ALIGN( _x ) __declspec(align(_x)) // Windows doesn't support aligned function parameters
#else
  #define AE_ALIGN( _x )
#endif

template < typename T, int N > char( &countof_helper( T(&)[ N ] ) )[ N ];
#define countof( _x ) ( (uint32_t)sizeof( countof_helper( _x ) ) )

inline void* aeAlignedAlloc( uint32_t size, uint32_t boundary )
{
#if _AE_WINDOWS_
  return _aligned_malloc( size, boundary );
#elif _AE_LINUX_
  return aligned_alloc( boundary, size );
#else
  // @HACK: macosx clang c++11 does not have aligned alloc
  return malloc( size );
#endif
}

inline void aeAlignedFree( void* p )
{
#if _AE_WINDOWS_
  _aligned_free( p );
#elif _AE_LINUX_
  free( p );
#else
  free( p );
#endif
}

inline void* aeRealloc( void* p, uint32_t size, uint32_t boundary )
{
#if _AE_WINDOWS_
  return _aligned_realloc( p, size, boundary );
#else
  aeCompilationWarning( "Aligned realloc() not determined on this platform" )
  return nullptr;
#endif
}

template < typename T >
const char* aeGetTypeName()
{
  const char* typeName = typeid( T ).name();
#ifdef _MSC_VER
  if ( strncmp( typeName, "class ", 6 ) == 0 )
  {
    typeName += 6;
  }
  else if ( strncmp( typeName, "struct ", 7 ) == 0 )
  {
    typeName += 7;
  }
#else
  while ( *typeName && isdigit( typeName[ 0 ] ) )
  {
    typeName++;
  }
#endif
  return typeName;
}

uint32_t aeGetPID();
uint32_t aeGetMaxConcurrentThreads();
bool aeIsDebuggerAttached();

#define AE_EXPORT extern "C"

// From: https://stackoverflow.com/questions/18547251/when-i-use-strlcpy-function-in-c-the-compilor-give-me-an-error
#ifndef HAVE_STRLCAT

inline
size_t
strlcat(char       *dst,
              const char *src,
          size_t     size)
{
  size_t    srclen;
  size_t    dstlen;

  dstlen = strlen(dst);
  size   -= dstlen + 1;

  if (!size)
    return (dstlen);

  srclen = strlen(src);

  if (srclen > size)
    srclen = size;

  memcpy(dst + dstlen, src, srclen);
  dst[dstlen + srclen] = '\0';

  return (dstlen + srclen);
}
#endif

#ifndef HAVE_STRLCPY

inline
size_t
strlcpy(char       *dst,
              const char *src,
          size_t      size)
{
  size_t    srclen;

  size --;

  srclen = strlen(src);

  if (srclen > size)
    srclen = size;

  memcpy(dst, src, srclen);
  dst[srclen] = '\0';

  return (srclen);
}
#endif

#ifdef _MSC_VER
# define strtok_r strtok_s
#endif

#define AE_CALL_CONST( _tx, _x, _tfn, _fn ) const_cast< _tfn* >( const_cast< const _tx* >( _x )->_fn() );

#endif
//------------------------------------------------------------------------------
// aeLog.hpp
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AE_LOG_HPP
#define AE_LOG_HPP

//------------------------------------------------------------------------------
// Log levels
//------------------------------------------------------------------------------
#define _AE_LOG_TRACE_ 0
#define _AE_LOG_DEBUG_ 1
#define _AE_LOG_INFO_ 2
#define _AE_LOG_WARN_ 3
#define _AE_LOG_ERROR_ 4
#define _AE_LOG_FATAL_ 5

extern const char* aeLogLevelNames[ 6 ];

//------------------------------------------------------------------------------
// Log colors
//------------------------------------------------------------------------------
#if _AE_WINDOWS_ || _AE_APPLE_
#define _AE_LOG_COLORS_ false
#else
#define _AE_LOG_COLORS_ true
extern const char* aeLogLevelColors[ 6 ];
#endif

//------------------------------------------------------------------------------
// Internal Logging functions
//------------------------------------------------------------------------------
void aeLogInternal( std::stringstream& os, const char* message );
void aeLogFormat( std::stringstream& os, uint32_t severity, const char* filePath, uint32_t line, const char* assertInfo, const char* format );

template < typename T, typename... Args >
void aeLogInternal( std::stringstream& os, const char* format, T value, Args... args )
{
  if ( !*format )
  {
    os << std::endl;
    return;
  }
  
  const char* head = format;
  while ( *head && *head != '#' )
  {
    head++;
  }
  if ( head > format )
  {
    os.write( format, head - format );
  }

  if ( *head == '#' )
  {
    os << value;
    head++;
  }

  aeLogInternal( os, head, args... );
}

template < typename... Args >
void aeLogInternal( uint32_t severity, const char* filePath, uint32_t line, const char* assertInfo, const char* format, Args... args )
{
  std::stringstream os;
  aeLogFormat( os, severity, filePath, line, assertInfo, format );
  aeLogInternal( os, format, args... );
}

#endif
//------------------------------------------------------------------------------
// aeLog.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AELOG_H
#define AELOG_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Logging functions
//------------------------------------------------------------------------------
#define AE_TRACE(...) aeLogInternal( _AE_LOG_TRACE_, __FILE__, __LINE__, "", __VA_ARGS__ )
#define AE_DEBUG(...) aeLogInternal( _AE_LOG_DEBUG_, __FILE__, __LINE__, "", __VA_ARGS__ )
#define AE_LOG(...) aeLogInternal( _AE_LOG_INFO_, __FILE__, __LINE__, "", __VA_ARGS__ )
#define AE_INFO(...) aeLogInternal( _AE_LOG_INFO_, __FILE__, __LINE__, "", __VA_ARGS__ )
#define AE_WARN(...) aeLogInternal( _AE_LOG_WARN_, __FILE__, __LINE__, "", __VA_ARGS__ )
#define AE_ERR(...) aeLogInternal( _AE_LOG_ERROR_, __FILE__, __LINE__, "", __VA_ARGS__ )

//------------------------------------------------------------------------------
// Assertion functions
//------------------------------------------------------------------------------
// @TODO: Use __analysis_assume( x ); on windows to prevent warning C6011 (Dereferencing NULL pointer)
#define AE_ASSERT( _x ) do { if ( !(_x) ) { aeLogInternal( _AE_LOG_FATAL_, __FILE__, __LINE__, "AE_ASSERT( " #_x " )", "" ); aeAssert(); } } while (0)
#define AE_ASSERT_MSG( _x, ... ) do { if ( !(_x) ) { aeLogInternal( _AE_LOG_FATAL_, __FILE__, __LINE__, "AE_ASSERT( " #_x " )", __VA_ARGS__ ); aeAssert(); } } while (0)
#define AE_FAIL() do { aeLogInternal( _AE_LOG_FATAL_, __FILE__, __LINE__, "", "" ); aeAssert(); } while (0)
#define AE_FAIL_MSG( ... ) do { aeLogInternal( _AE_LOG_FATAL_, __FILE__, __LINE__, "", __VA_ARGS__ ); aeAssert(); } while (0)

//------------------------------------------------------------------------------
// Static assertion functions
//------------------------------------------------------------------------------
#define AE_STATIC_ASSERT( _x ) static_assert( _x, "static assert" )
#define AE_STATIC_ASSERT_MSG( _x, _m ) static_assert( _x, _m )
#define AE_STATIC_FAIL( _m ) static_assert( 0, _m )

#endif
//------------------------------------------------------------------------------
// aeMath.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEMATH_H
#define AEMATH_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeMath functions
//------------------------------------------------------------------------------
namespace aeMath
{
  extern const float PI;
  extern const float TWO_PI;
  extern const float HALF_PI;

  template< typename T >
  T&& Min( T&& v )
  {
    return std::forward< T >( v );
  }
  template< typename T0, typename T1, typename... Tn >
  auto Min( T0&& v0, T1&& v1, Tn&&... vn )
  {
    return ( v0 < v1 ) ? Min( v0, std::forward< Tn >( vn )... ) : Min( v1, std::forward< Tn >( vn )... );
  }
  
  template< typename T >
  T&& Max( T&& v )
  {
    return std::forward< T >( v );
  }
  template< typename T0, typename T1, typename... Tn >
  auto Max( T0&& v0, T1&& v1, Tn&&... vn )
  {
    return ( v0 > v1 ) ? Max( v0, std::forward< Tn >( vn )... ) : Max( v1, std::forward< Tn >( vn )... );
  }

  template<typename T>
  inline T Abs(const T &x)
  {
    if(x < static_cast<T>(0))
    {
      return x * static_cast<T>(-1);
    }
    return x;
  }

  template < typename T >
  inline T Clip( T x, T min, T max )
  {
    return Min( Max( x, min ), max );
  }

  inline float Clip01( float x )
  {
    return Clip( x, 0.0f, 1.0f );
  }

  inline float DegToRad( float degrees )
  {
    return degrees * PI / 180.0f;
  }

  inline float RadToDeg( float radians )
  {
    return radians * 180.0f / PI;
  }

  inline int32_t Ceil( float f )
  {
    bool positive = f >= 0.0f;
    if(positive)
    {
      int i = static_cast<int>(f);
      if( f > static_cast<float>(i) ) return i + 1;
      else return i;
    }
    else return static_cast<int>(f);
  }

  inline int32_t Floor( float f )
  {
    bool negative = f < 0.0f;
    if(negative)
    {
      int i = static_cast<int>(f);
      if( f < static_cast<float>(i) ) return i - 1;
      else return i;
    }
    else return static_cast<int>(f);
  }

  inline int32_t Round( float f )
  {
    if( f >= 0.0f ) return (int32_t)( f + 0.5f );
    else return (int32_t)( f - 0.5f );
  }

  inline uint32_t Mod( uint32_t i, uint32_t n )
  {
    return i % n;
  }

  inline int Mod( int32_t i, int32_t n )
  {
    if( i < 0 )
    {
      return ( ( i % n ) + n ) % n;
    }
    else
    {
      return i % n;
    }
  }

  inline float Mod( float f, float n )
  {
    return fmodf( fmodf( f, n ) + n, n );
  }

  inline float Pow( float x, float e )
  {
    return powf( x, e );
  }

  inline float Cos( float x )
  {
    return cosf( x );
  }

  inline float Sin( float x )
  {
    return sinf( x );
  }

  inline float Atan2( float y, float x )
  {
    return atan2( y, x );
  }

  template< typename T >
  constexpr T MaxValue()
  {
    return std::numeric_limits< T >::max();
  }

  template< typename T >
  constexpr T MinValue()
  {
    return std::numeric_limits< T >::min();
  }

  template<>
  constexpr float MaxValue< float >()
  {
    return std::numeric_limits< float >::infinity();
  }

  template<>
  constexpr float MinValue< float >()
  {
    return -1 * std::numeric_limits< float >::infinity();
  }

  template<>
  constexpr double MaxValue< double >()
  {
    return std::numeric_limits< double >::infinity();
  }

  template<>
  constexpr double MinValue< double >()
  {
    return -1 * std::numeric_limits< double >::infinity();
  }

  template< typename T >
  T Lerp( T start, T end, float t )
  {
    return start + ( end - start ) * t;
  }

  inline float Delerp( float start, float end, float value )
  {
    return ( value - start ) / ( end - start );
  }

  inline float Delerp01( float start, float end, float value )
  {
    return Clip01( ( value - start ) / ( end - start ) );
  }

  template< typename T >
  T DtLerp( T value, float snappiness, float dt, T target )
  {
    return aeMath::Lerp( target, value, exp2( -exp2( snappiness ) * dt ) );
  }

  inline float DtLerpAngle( float value, float snappiness, float dt, float target )
  {
    target = aeMath::Mod( target, aeMath::TWO_PI );
    float innerDist = aeMath::Abs( target - value );
    float preDist = aeMath::Abs( ( target - aeMath::TWO_PI ) - value );
    float postDist = aeMath::Abs( ( target + aeMath::TWO_PI ) - value );
    if ( innerDist >= preDist || innerDist >= postDist )
    {
      if ( preDist < postDist )
      {
        target -= aeMath::TWO_PI;
      }
      else
      {
        target += aeMath::TWO_PI;
      }
    }
    value = aeMath::DtLerp( value, snappiness, dt, target );
    return aeMath::Mod( value, aeMath::TWO_PI );
  }

  inline int32_t Random( int32_t min, int32_t max )
  {
    if ( min >= max )
    {
      return min;
    }
    return min + ( rand() % ( max - min ) );
  }

  inline float Random( float min, float max )
  {
    if ( min >= max )
    {
      return min;
    }
    return min + ( ( rand() / (float)RAND_MAX ) * ( max - min ) );
  }

  inline bool RandomBool()
  {
    return Random( 0, 2 );
  }

  template < typename T >
  class RandomValue
  {
  public:
    RandomValue() {}
    RandomValue( T min, T max );
    RandomValue( T value );

    void SetMin( T min );
    void SetMax( T max );

    T GetMin() const;
    T GetMax() const;

    T Get() const;
    operator T() const;

  private:
    T m_min;
    T m_max;
  };

  namespace Interpolation
  {
    template< typename T >
    T Linear( T start, T end, float t )
    {
      return start + ( ( end - start ) * t );
    }

    template< typename T >
    T Cosine( T start, T end, float t )
    {
      t = (1-cos(t*aeMath::PI))/2;

      // float angle = ( t * aeMath::PI ) + aeMath::PI;
      // t = aeMath::Cos( angle );
      // t = ( t + 1 ) / 2.0f;

      // return start + ( ( end - start ) * t );
      return start.Lerp( end, t );
    }
  }
}

//------------------------------------------------------------------------------
// aeFloat2 struct
//------------------------------------------------------------------------------
struct AE_ALIGN(16) aeFloat2
{
  union
  {
    struct
    {
      float x;
      float y;
    };
    float data[ 2 ];
  };

  const static aeFloat2 Zero;

  aeFloat2() = default;
  aeFloat2( const aeFloat2& ) = default;
  aeFloat2( bool ) = delete;
  explicit aeFloat2( float v ) : x( v ), y( v ) {}
  aeFloat2( float x, float y ) : x( x ), y( y ) {}
  explicit aeFloat2( const struct aeInt2& v );
  static aeFloat2 FromAngle( float angle ) { return aeFloat2( aeMath::Cos( angle ), aeMath::Sin( angle ) );}

  bool operator ==( const aeFloat2& o ) const { return x == o.x && y == o.y; }
  bool operator !=( const aeFloat2& o ) const { return !( *this == o ); }
  aeFloat2 operator- () const;
  aeFloat2 operator+ ( const aeFloat2 &v ) const;
  void operator+= (const aeFloat2 &v);
  aeFloat2 operator- ( const aeFloat2 &v ) const;
  void operator-= ( const aeFloat2 &v );
  float Dot( const aeFloat2 &v ) const;
  static float Dot( const aeFloat2& a, const aeFloat2& b );
  float Length() const;
  float LengthSquared() const;
  float Atan2() const;
  aeFloat2 operator* (const float s) const;
  void operator*=( const float s );
  aeFloat2 operator* (const aeFloat2 s) const;
  void operator*=( const aeFloat2 s );
  aeFloat2 operator/ (const float s) const;
  void operator/= (const float s);
  aeFloat2 operator/ ( const aeFloat2 s ) const;
  void operator/= ( const aeFloat2 s );
  aeFloat2 Lerp(const aeFloat2& end, float t) const;
  float Normalize();
  aeFloat2 NormalizeCopy() const;
  float SafeNormalize();
  aeFloat2 SafeNormalizeCopy() const;
  aeInt2 NearestCopy() const;
  aeInt2 FloorCopy() const;
  aeInt2 CeilCopy() const;
  aeFloat2 RotateCopy( float rotation ) const;
  float GetAngle() const;
  static aeFloat2 Reflect( aeFloat2 v, aeFloat2 n );
};

inline std::ostream& operator<<( std::ostream& os, aeFloat2 v )
{
  return os << v.x << " " << v.y;
}

//------------------------------------------------------------------------------
// aeInt2 struct
//------------------------------------------------------------------------------
struct aeInt2
{
  union
  {
    struct
    {
      int32_t x;
      int32_t y;
    };
    int32_t data[ 2 ];
  };
  int32_t pad[ 2 ];

  const static aeInt2 Zero;
  const static aeInt2 Up;
  const static aeInt2 Down;
  const static aeInt2 Left;
  const static aeInt2 Right;

  aeInt2() = default;
  aeInt2( const aeInt2& ) = default;
  aeInt2( bool ) = delete;

  explicit aeInt2( int32_t _v ) : x( _v ), y( _v ) {}
  explicit aeInt2( const struct aeInt3& v );
  aeInt2( int32_t _x, int32_t _y ) : x( _x ), y( _y ) {}
  // @NOTE: No automatic conversion from aeFloat2 because rounding type should be explicit!
  
  int32_t& operator[]( int32_t i ) { return data[ i ]; }
  const int32_t& operator[]( int32_t i ) const { return data[ i ]; }
  
  bool operator ==( const aeInt2& o ) const { return x == o.x && y == o.y; }
  bool operator !=( const aeInt2& o ) const { return !( *this == o ); }
  
  aeInt2 operator- () const;

  aeInt2& operator+=( const aeInt2 &v );
  aeInt2& operator-=( const aeInt2 &v );
  aeInt2 operator+( const aeInt2 &v ) const;
  aeInt2 operator-( const aeInt2 &v ) const;

  aeInt2 operator* ( const int32_t s ) const;
  void operator*= ( const int32_t s );
  aeInt2 operator* ( const aeInt2& v ) const;
  aeInt2& operator*= ( const aeInt2& v );
  aeInt2 operator/ ( const int32_t s ) const;
  void operator/= ( const int32_t s );
  aeInt2 operator/ ( const aeInt2& v ) const;
  aeInt2& operator/= ( const aeInt2& v );

  aeFloat2 operator* ( const float s ) const;
  void operator*= ( const float s ) = delete;
  aeFloat2 operator/ ( const float s ) const;
  void operator/= ( const float s ) = delete;
};

inline std::ostream& operator<<( std::ostream& os, aeInt2 v )
{
  return os << v.x << " " << v.y;
}

//------------------------------------------------------------------------------
// aeFloat3 struct
//------------------------------------------------------------------------------
class AE_ALIGN(16) aeFloat3
{
public:
  union
  {
    struct
    {
      float x;
      float y;
      float z;
    };
    float data[ 3 ];
  };
  float pad;

  const static aeFloat3 Zero;
  const static aeFloat3 Up;
  const static aeFloat3 Down;
  const static aeFloat3 Left;
  const static aeFloat3 Right;
  const static aeFloat3 Forward;
  const static aeFloat3 Backward;

  aeFloat3() = default;
  aeFloat3( const aeFloat3& ) = default;
  aeFloat3( bool ) = delete;

  explicit aeFloat3( float _v ) : x( _v ), y( _v ), z( _v ), pad( 0.0f ) {}
  aeFloat3( float _x, float _y, float _z ) : x( _x ), y( _y ), z( _z ), pad( 0.0f ) {}
  aeFloat3( const float( &v )[ 3 ] ) : x( v[ 0 ] ), y( v[ 1 ] ), z( v[ 2 ] ), pad( 0.0f ) {}
  aeFloat3( const float( &v )[ 4 ] ) : x( v[ 0 ] ), y( v[ 1 ] ), z( v[ 2 ] ), pad( 0.0f ) {}
  explicit aeFloat3( float*& v ) : x( v[ 0 ] ), y( v[ 1 ] ), z( v[ 2 ] ), pad( 0.0f ) {}
  explicit aeFloat3( const float*& v ) : x( v[ 0 ] ), y( v[ 1 ] ), z( v[ 2 ] ), pad( 0.0f ) {}
  aeFloat3( aeFloat2 xy, float z ) : x( xy.x ), y( xy.y ), z( z ), pad( 0.0f ) {}
  explicit aeFloat3( aeFloat2 xy ) : x( xy.x ), y( xy.y ), z( 0.0f ), pad( 0.0f ) {}
  explicit operator aeFloat2() const { return aeFloat2( x, y ); }
  explicit aeFloat3( const struct aeInt3& v );
  void SetZero();

  float& operator[]( int32_t i ) { return data[ i ]; }
  float operator[]( int32_t i ) const { return data[ i ]; }
  aeFloat2 GetXY() const { return aeFloat2( x, y ); }

  bool operator==(const aeFloat3& v) const;
  bool operator!=(const aeFloat3& v) const;
  bool operator<(const aeFloat3& v) const;
  bool operator>(const aeFloat3& v) const;
  bool operator<=(const aeFloat3& v) const;
  bool operator>=(const aeFloat3& v) const;

  aeFloat3 operator+ (const aeFloat3& v) const;
  void operator+= (const aeFloat3& v);
  void operator+= (const aeFloat2& v);
  aeFloat3 operator- (void) const;
  aeFloat3 operator- (const aeFloat3& v) const;
  void operator-= (const aeFloat3& v);
  
  aeFloat3 operator* (const float s) const;
  void operator*= (const float s);
  aeFloat3 operator* ( const aeFloat3& v ) const;
  aeFloat3& operator*= ( const aeFloat3& v );
  static aeFloat3 Multiply( const aeFloat3& a, const aeFloat3& b );
  aeFloat3 operator/ (const float s) const;
  void operator/= (const float s);
  
  float Dot(const aeFloat3& v) const;
  static float Dot( const aeFloat3& a, const aeFloat3& b );
  aeFloat3 operator% (const aeFloat3& v) const;
  void AddScaledVector(const aeFloat3& v, const float s);
  aeFloat3 ComponentProduct(const aeFloat3& v) const;
  void ComponentProductUpdate(const aeFloat3& v);

  float Length() const;
  float LengthSquared() const;
  float GetDistance(const aeFloat3 &other) const;
  float GetDistanceSquared(const aeFloat3 &other) const;
  
  aeFloat3& Trim(const float s);
  aeFloat3& ZeroAxis( aeFloat3 axis ); // Zero components along arbitrary axis (ie vec dot axis == 0)
  float Normalize();
  aeFloat3 NormalizeCopy() const;
  float SafeNormalize();
  aeFloat3 SafeNormalizeCopy() const;
  
  aeInt3 NearestCopy() const;
  aeInt3 FloorCopy() const;
  aeInt3 CeilCopy() const;

  float GetAngleBetween(const aeFloat3& v) const;
  void AddRotationXY(float rotation);
  aeFloat3 RotateCopy( aeFloat3 axis, float angle ) const;
  aeFloat3 Lerp(const aeFloat3& end, float t) const;
  aeFloat3 Slerp(const aeFloat3& end, float t) const;

  static aeFloat3 ProjectPoint( const class aeFloat4x4& projection, aeFloat3 p );
};

inline std::ostream& operator<<( std::ostream& os, aeFloat3 v )
{
  return os << v.x << " " << v.y << " " << v.z;
}

//------------------------------------------------------------------------------
// aeInt3 struct
//------------------------------------------------------------------------------
struct AE_ALIGN(16) aeInt3
{
  union
  {
    struct
    {
      int32_t x;
      int32_t y;
      int32_t z;
    };
    int32_t data[ 3 ];
  };
  int32_t pad;

  aeInt3() = default;
  aeInt3( const aeInt3& ) = default;
  aeInt3( bool ) = delete;

  explicit aeInt3( int32_t _v ) : x( _v ), y( _v ), z( _v ), pad( 0 ) {}
  aeInt3( int32_t _x, int32_t _y, int32_t _z ) : x( _x ), y( _y ), z( _z ), pad( 0 ) {}
  aeInt3( aeInt2 xy, int32_t _z ) : x( xy.x ), y( xy.y ), z( _z ), pad( 0 ) {}
  aeInt3( const int32_t( &v )[ 3 ] ) : x( v[ 0 ] ), y( v[ 1 ] ), z( v[ 2 ] ), pad( 0 ) {}
  aeInt3( const int32_t( &v )[ 4 ] ) : x( v[ 0 ] ), y( v[ 1 ] ), z( v[ 2 ] ), pad( 0 ) {}
  explicit aeInt3( int32_t*& v ) : x( v[ 0 ] ), y( v[ 1 ] ), z( v[ 2 ] ), pad( 0 ) {}
  explicit aeInt3( const int32_t*& v ) : x( v[ 0 ] ), y( v[ 1 ] ), z( v[ 2 ] ), pad( 0 ) {}
  // @NOTE: No conversion from aeFloat3 because rounding type should be explicit!
  
  int32_t& operator[]( int32_t i ) { return data[ i ]; }
  const int32_t& operator[]( int32_t i ) const { return data[ i ]; }
  aeInt2 GetXY() const { return aeInt2( x, y ); }
  
  bool operator ==( const aeInt3& o ) const { return x == o.x && y == o.y && z == o.z; }
  bool operator !=( const aeInt3& o ) const { return !( *this == o ); }
  
  aeInt3 operator+( const aeInt3& v ) const;
  aeInt3 operator-( const aeInt3& v ) const;
  aeInt3& operator+=( const aeInt3& v );
  aeInt3& operator-=( const aeInt3& v );

  aeInt3 operator*( int32_t s ) const;
  aeInt3 operator*( const aeInt3& s ) const;
  aeInt3 operator/( int32_t s ) const;
  aeInt3 operator/( const aeInt3& s ) const;
  void operator*=( int32_t s );
  void operator*=( const aeInt3& s );
  void operator/=( int32_t s );
  void operator/=( const aeInt3& s );
};

inline std::ostream& operator<<( std::ostream& os, aeInt3 v )
{
  return os << v.x << " " << v.y << " " << v.z;
}

namespace aeMath
{
  inline aeFloat3 Min( aeFloat3 v0, aeFloat3 v1 )
  {
    return aeFloat3(
      Min( v0.x, v1.x ),
      Min( v0.y, v1.y ),
      Min( v0.z, v1.z )
    );
  }

  inline aeFloat3 Max( aeFloat3 v0, aeFloat3 v1 )
  {
    return aeFloat3(
      Max( v0.x, v1.x ),
      Max( v0.y, v1.y ),
      Max( v0.z, v1.z )
    );
  }

  inline aeFloat3 Abs( aeFloat3 v )
  {
    return aeFloat3(
      Abs( v.x ),
      Abs( v.y ),
      Abs( v.z )
    );
  }

  inline aeInt3 Min( aeInt3 v0, aeInt3 v1 )
  {
    return aeInt3(
      Min( v0.x, v1.x ),
      Min( v0.y, v1.y ),
      Min( v0.z, v1.z )
    );
  }

  inline aeInt3 Max( aeInt3 v0, aeInt3 v1 )
  {
    return aeInt3(
      Max( v0.x, v1.x ),
      Max( v0.y, v1.y ),
      Max( v0.z, v1.z )
    );
  }

  inline aeInt3 Abs( aeInt3 v )
  {
    return aeInt3(
      Abs( v.x ),
      Abs( v.y ),
      Abs( v.z )
    );
  }

  inline aeFloat3 Ceil( aeFloat3 v )
  {
    return aeFloat3(
      Ceil( v.x ),
      Ceil( v.y ),
      Ceil( v.z )
    );
  }

  inline aeFloat3 Floor( aeFloat3 v )
  {
    return aeFloat3(
      Floor( v.x ),
      Floor( v.y ),
      Floor( v.z )
    );
  }
}

//------------------------------------------------------------------------------
// aeFloat4 struct
//------------------------------------------------------------------------------
class AE_ALIGN(16) aeFloat4
{
public:
  union
  {
    struct
    {
      float x;
      float y;
      float z;
      float w;
    };
    float data[4];
  };

  const static aeFloat4 Zero;

  aeFloat4() = default;
  aeFloat4( const aeFloat4& ) = default;
  aeFloat4( bool ) = delete;

  explicit aeFloat4(float v) : x(v), y(v), z(v), w(v) {}
  aeFloat4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) {}
  aeFloat4( aeFloat3 xyz, float w ) : x( xyz.x ), y( xyz.y ), z( xyz.z ), w( w ) {}
  aeFloat4( aeFloat2 xy, float z, float w ) : x( xy.x ), y( xy.y ), z( z ), w( w ) {}
  explicit aeFloat4( aeFloat3 xyz ) : x( xyz.x ), y( xyz.y ), z( xyz.z ), w( 0.0f ) {}
  explicit aeFloat4( aeFloat2 xy ) : x( xy.x ), y( xy.y ), z( 0.0f ), w( 0.0f ) {}
  explicit operator aeFloat3() const { return aeFloat3( x, y, z ); }
  explicit operator aeFloat2() const { return aeFloat2( x, y ); }
  aeFloat4(const float (&v)[3]) : x(v[0]), y(v[1]), z(v[2]), w(0.0f) {}
  aeFloat4(const float (&v)[4]) : x(v[0]), y(v[1]), z(v[2]), w(v[3]) {}
  aeFloat2 GetXY() const { return aeFloat2( x, y ); }
  aeFloat2 GetZW() const { return aeFloat2( z, w ); }
  aeFloat3 GetXYZ() const { return aeFloat3( x, y, z ); }
  float operator[](unsigned i) const;
  float& operator[](unsigned i);
  aeFloat4 operator-(void) const;
  aeFloat4 operator+ (const aeFloat4& v) const;
  void operator+= (const aeFloat4& v);
  aeFloat4 operator- (const aeFloat4& v) const;
  void operator-= (const aeFloat4& v);
  aeFloat4 operator* (const float s) const;
  void operator*= (const float s);
  aeFloat4 operator/ (const float s) const;
  void operator/= (const float s);
  float operator* (const aeFloat4& v) const;
  void AddScaledVector(const aeFloat4& v, const float s);
  aeFloat4 ComponentProduct(const aeFloat4& v) const;
  void ComponentProductUpdate(const aeFloat4& v);
  void Invert();
  float Length() const;
  float LengthSquared() const;
  void Trim(const float s);
  float Normalize();
  aeFloat4 NormalizeCopy() const;
  float SafeNormalize();
  aeFloat4 SafeNormalizeCopy() const;
  void SetZero();
  bool operator==(const aeFloat4& v) const;
  bool operator!=(const aeFloat4& v) const;
  bool operator<(const aeFloat4& v) const;
  bool operator>(const aeFloat4& v) const;
  bool operator<=(const aeFloat4& v) const;
  bool operator>=(const aeFloat4& v) const;
};

inline std::ostream& operator<<( std::ostream& os, aeFloat4 v )
{
  return os << v.x << " " << v.y << " " << v.z << " " << v.w;
}

namespace aeMath
{
  inline aeFloat4 Ceil( aeFloat4 v )
  {
    return aeFloat4(
      Ceil( v.x ),
      Ceil( v.y ),
      Ceil( v.z ),
      Ceil( v.w )
    );
  }

  inline aeFloat4 Floor( aeFloat4 v )
  {
    return aeFloat4(
      Floor( v.x ),
      Floor( v.y ),
      Floor( v.z ),
      Floor( v.w )
    );
  }
}

template< typename T >
struct _aeInt4
{
  union
  {
    struct
    {
      T x;
      T y;
      T z;
      T w;
    };
    T data[ 4 ];
  };
  
  _aeInt4() = default;
  _aeInt4( const _aeInt4& ) = default;
  _aeInt4( bool ) = delete;
  
  _aeInt4( T _x ) : x( _x ), y( _x ), z( _x ), w( _x ) {}
  _aeInt4( T _x, T _y, T _z, T _w ) : x( _x ), y( _y ), z( _z ), w( _w ) {}
  T& operator[]( T i ) { return data[ i ]; }
  const T& operator[]( T i ) const { return data[ i ]; }
  bool operator ==( const _aeInt4& o ) const { return x == o.x && y == o.y && z == o.z && w == o.w; }
  bool operator !=( const _aeInt4& o ) const { return x != o.x || y != o.y || z != o.z || w != o.w; }
};

typedef _aeInt4< int32_t > aeInt4;

//------------------------------------------------------------------------------
// aeFloat4x4 struct
//------------------------------------------------------------------------------
class AE_ALIGN(16) aeFloat4x4
{
public:
  float data[ 16 ];

  aeFloat4x4() = default;
  aeFloat4x4( const aeFloat4x4& ) = default;

  aeFloat4x4(float v0,  float v1,  float v2,  float v3,
    float v4,  float v5,  float v6,  float v7,
    float v8,  float v9,  float v10, float v11,
    float v12, float v13, float v14, float v15)
  {
    data[0]  = v0;  data[1]  = v1;  data[2]  = v2;  data[3]  = v3;
    data[4]  = v4;  data[5]  = v5;  data[6]  = v6;  data[7]  = v7;
    data[8]  = v8;  data[9]  = v9;  data[10] = v10; data[11] = v11;
    data[12] = v12; data[13] = v13; data[14] = v14; data[15] = v15;
  }

  static aeFloat4x4 Identity()
  {
    aeFloat4x4 r;
    r.data[0]  = 1; r.data[1]  = 0; r.data[2]  = 0; r.data[3]  = 0;
    r.data[4]  = 0; r.data[5]  = 1; r.data[6]  = 0; r.data[7]  = 0;
    r.data[8]  = 0; r.data[9]  = 0; r.data[10] = 1; r.data[11] = 0;
    r.data[12] = 0; r.data[13] = 0; r.data[14] = 0; r.data[15] = 1;
    return r;
  }

  // Constructor helpers
  static aeFloat4x4 Translation( const aeFloat3& p );
  static aeFloat4x4 Rotation( aeFloat3 forward0, aeFloat3 up0, aeFloat3 forward1, aeFloat3 up1 );
  static aeFloat4x4 RotationX( float angle );
  static aeFloat4x4 RotationY( float angle );
  static aeFloat4x4 RotationZ( float angle );
  static aeFloat4x4 Scaling( const aeFloat3& s );

  static aeFloat4x4 WorldToView( aeFloat3 position, aeFloat3 forward, aeFloat3 up ); // @TODO: Verify handedness
  static aeFloat4x4 ViewToProjection( float fov, float aspectRatio, float nearPlane, float farPlane );

  // Operators
  bool operator== ( const aeFloat4x4& o ) const { return memcmp( o.data, data, sizeof(data) ) == 0; }
  bool operator!= ( const aeFloat4x4& o ) const { return !operator== ( o ); }
  aeFloat4 operator*(const aeFloat4& v) const;
  aeFloat4x4 operator*(const aeFloat4x4& m) const;
  void operator*=(const aeFloat4x4& m);
  bool SetInverse(const aeFloat4x4& m);

  aeFloat4x4 Inverse() const; //TODO: Rename this! Caused a bunch of problems debugging graphics...
  bool Invert();           //TODO: Rename. See above
  aeFloat4x4& SetTranspose();
  aeFloat4x4 GetTransposeCopy() const;
  aeFloat4x4& SetOrientation( const class aeQuat& q );
  aeFloat3 TransformInverse(const aeFloat3& v) const;
  aeFloat3 TransformDirection(const aeFloat3& v) const;
  aeFloat3 TransformInverseDirection(const aeFloat3& v) const;
  void SetDiagonal(float a, float b, float c);
  aeFloat3 GetAxisVector(int col) const;
  aeFloat3 GetPosition() const;
  aeQuat GetRotation() const;
  void SetPosition( const aeFloat3& p );
  void SetAxisVector(unsigned col, const aeFloat3 &v);
  aeFloat4 GetRowVector(int row) const;
  void SetRowVector(unsigned row, const aeFloat3 &v);
  void SetRowVector(unsigned row, const aeFloat4 &v);
  aeFloat4x4& SetIdentity();
  aeFloat4x4& SetTranslate(float X, float Y, float Z);
  aeFloat4x4& SetTranslate(const aeFloat3 &translation);
  aeFloat4x4& SetTranslation(float X, float Y, float Z);
  aeFloat4x4& SetTranslation(const aeFloat3 &translation);
  aeFloat3 GetTranslation() const;
  aeFloat3 GetScale() const;
  aeFloat4x4& SetScale(float X, float Y, float Z);
  aeFloat4x4& SetScale(const aeFloat3 &scale);
  aeFloat4x4& SetScaleKeepTranslate(float X, float Y, float Z);
  aeFloat4x4& SetScaleKeepTranslate(const aeFloat3 &scale);
  aeFloat4x4& SetRotateX(float angle);
  aeFloat4x4& SetRotateY(float angle);
  aeFloat4x4& SetRotateZ(float angle);
  aeFloat4x4& RemoveScaling();

  // Transformation helpers
  aeFloat4x4& Translate( aeFloat3 t );
  aeFloat4x4& Scale( aeFloat3 s );
  aeFloat4x4& RotateX( float angle );
  aeFloat4x4& RotateY( float angle );
  aeFloat4x4& RotateZ( float angle );
};

inline std::ostream& operator << ( std::ostream& os, const aeFloat4x4& mat )
{
  os << mat.data[ 0 ] << " " << mat.data[ 1 ] << " " << mat.data[ 2 ] << " " << mat.data[ 3 ]
    << " " << mat.data[ 4 ] << " " << mat.data[ 5 ] << " " << mat.data[ 6 ] << " " << mat.data[ 7 ]
    << " " << mat.data[ 8 ] << " " << mat.data[ 9 ] << " " << mat.data[ 10 ] << " " << mat.data[ 11 ]
    << " " << mat.data[ 12 ] << " " << mat.data[ 13 ] << " " << mat.data[ 14 ] << " " << mat.data[ 15 ];
  return os;
}

//------------------------------------------------------------------------------
// aeQuat class
//------------------------------------------------------------------------------
class AE_ALIGN(16) aeQuat
{
public:
  union
  {
    struct
    {
      float i;
      float j;
      float k;
      float r;
    };
    float data[ 4 ];
  };
  
  aeQuat() = default;
  aeQuat( const aeQuat& ) = default;

  aeQuat( const float i, const float j, const float k, const float r ) : i(i), j(j), k(k), r(r) {}
  explicit aeQuat( aeFloat3 v ) : i(v.x), j(v.y), k(v.z), r(0.0f) {}
  aeQuat( aeFloat3 forward, aeFloat3 up, bool prioritizeUp = true );
  aeQuat( aeFloat3 axis, float angle );
  static aeQuat Identity() { return aeQuat( 0.0f, 0.0f, 0.0f, 1.0f ); }

  void Normalize();
  bool operator==( const aeQuat& q ) const;
  bool operator!=( const aeQuat& q ) const;
  aeQuat& operator*= ( const aeQuat& q );
  aeQuat operator* ( const aeQuat& q ) const;
  float Dot( const aeQuat& q ) const;
  aeQuat const operator* ( float s ) const;
  void AddScaledVector( const aeFloat3& v, float s );
  void RotateByVector( const aeFloat3& v );
  void SetDirectionXY( const aeFloat3& v );
  aeFloat3 GetDirectionXY() const;
  void ZeroXY();
  void GetAxisAngle( aeFloat3* axis, float* angle ) const;
  void AddRotationXY( float rotation);
  aeQuat Nlerp( aeQuat end, float t ) const;
  aeFloat4x4 GetTransformMatrix() const;
  aeQuat  GetInverse() const;
  aeQuat& SetInverse();
  aeFloat3 Rotate( aeFloat3 v ) const;
};

//------------------------------------------------------------------------------
// aeRect class
//------------------------------------------------------------------------------
struct aeRect
{
  aeRect() = default;
  aeRect( const aeRect& ) = default;

  aeRect( float x, float y, float w, float h ) : x(x), y(y), w(w), h(h) {}
  aeRect( aeFloat2 p0, aeFloat2 p1 );
  static aeRect Zero();

  explicit operator aeFloat4() const { return aeFloat4( x, y, w, h ); }
  
  aeFloat2 GetMin() const { return aeFloat2( x, y ); }
  aeFloat2 GetMax() const { return aeFloat2( x + w, y + h ); }
  aeFloat2 GetSize() const { return aeFloat2( w, h ); }

  bool Contains( aeFloat2 pos ) const;
  void Expand( aeFloat2 pos ); // @NOTE: Zero size rect is maintained by Expand()

  bool GetIntersection( const aeRect& other, aeRect* intersectionOut ) const;
  
  float x;
  float y;
  float w;
  float h;
};

inline std::ostream& operator<<( std::ostream& os, aeRect r )
{
  return os << r.x << " " << r.y << " " << r.w << " " << r.h;
}

//------------------------------------------------------------------------------
// aeRectInt class
//------------------------------------------------------------------------------
struct aeRectInt
{
  aeRectInt() = default;
  aeRectInt( const aeRectInt& ) = default;

  aeRectInt( int32_t x, int32_t y, int32_t w, int32_t h ) : x(x), y(y), w(w), h(h) {}

  static aeRectInt Zero();
  aeInt2 GetPos() const { return aeInt2( x, y ); }
  aeInt2 GetSize() const { return aeInt2( w, h ); }
  bool Contains( aeInt2 pos ) const;
  bool Intersects( aeRectInt other ) const;
  void Expand( aeInt2 pos ); // @NOTE: Zero size rect is expanded to 1x1 grid square by Expand()
  
  int32_t x;
  int32_t y;
  int32_t w;
  int32_t h;
};

inline std::ostream& operator<<( std::ostream& os, aeRectInt r )
{
  return os << r.x << " " << r.y << " " << r.w << " " << r.h;
}

//------------------------------------------------------------------------------
// aePlane class
//------------------------------------------------------------------------------
class aePlane
{
public:
  aePlane() = default;
  aePlane( aeFloat3 point, aeFloat3 normal );

  bool IntersectRay( aeFloat3 pos, aeFloat3 dir, float* tOut, aeFloat3* out ) const;

private:
  aeFloat3 m_point;
  aeFloat3 m_normal;
};

//------------------------------------------------------------------------------
// aeLineSegment class
//------------------------------------------------------------------------------
class aeLineSegment
{
public:
  aeLineSegment() = default;
  aeLineSegment( aeFloat3 p0, aeFloat3 p1 );

  float GetMinDistance( aeFloat3 p, aeFloat3* nearestOut = nullptr ) const; // @TODO: GetDistance()

private:
  aeFloat3 m_p0;
  aeFloat3 m_p1;
};

//------------------------------------------------------------------------------
// aeCircle class
//------------------------------------------------------------------------------
class aeCircle
{
public:
  aeCircle() = default;
  aeCircle( aeFloat2 point, float radius );

  static float GetArea( float radius );

  aeFloat2 GetCenter() const { return m_point; }
  float GetRadius() const { return m_radius; }
  void SetCenter( aeFloat2 point ) { m_point = point; }
  void SetRadius( float radius ) { m_radius = radius; }

  bool Intersect( const aeCircle& other, aeFloat2* out ) const;

private:
  friend std::ostream& operator<<( std::ostream& os, const aeCircle& c );

  aeFloat2 m_point;
  float m_radius;
};

inline std::ostream& operator<<( std::ostream& os, const aeCircle& c )
{
  return os << "(" << c.m_point << " : " << c.m_radius << ")";
}

//------------------------------------------------------------------------------
// aeSphere class
//------------------------------------------------------------------------------
class aeSphere
{
public:
  aeSphere() = default;
  aeSphere( aeFloat3 center, float radius ) : center( center ), radius( radius ) {}

  bool Raycast( aeFloat3 origin, aeFloat3 direction, float* tOut = nullptr, aeFloat3* pOut = nullptr ) const;
  bool SweepTriangle( aeFloat3 direction, const aeFloat3* points, aeFloat3 normal,
    float* outNearestDistance, aeFloat3* outNearestIntersectionPoint, aeFloat3* outNearestPolygonIntersectionPoint, class aeDebugRender* debug ) const;

  aeFloat3 center = aeFloat3::Zero;
  float radius = 0.0f;
};

//------------------------------------------------------------------------------
// aeAABB class
//------------------------------------------------------------------------------
class aeAABB
{
public:
  aeAABB() = default;
  aeAABB( const aeAABB& ) = default;
  aeAABB( aeFloat3 p0, aeFloat3 p1 );
  explicit aeAABB( const aeSphere& sphere );

  void Expand( aeFloat3 p );
  void Expand( aeAABB other );
  void Expand( float boundary );

  aeFloat3 GetMin() const { return m_min; }
  aeFloat3 GetMax() const { return m_max; }
  aeFloat3 GetCenter() const { return ( m_min + m_max ) * 0.5f; }
  aeFloat3 GetHalfSize() const { return ( m_max - m_min ) * 0.5f; }
  aeFloat4x4 GetTransform() const;

  float GetMinDistance( aeFloat3 p ) const; // @TODO: GetDistanceFromSurface()
  bool Intersect( aeAABB other ) const;
  bool IntersectRay( aeFloat3 p, aeFloat3 d, aeFloat3* pOut = nullptr, float* tOut = nullptr ) const;

private:
  aeFloat3 m_min;
  aeFloat3 m_max;
};

inline std::ostream& operator<<( std::ostream& os, aeAABB aabb )
{
  return os << "[" << aabb.GetMin() << ", " << aabb.GetMax() << "]";
}

//------------------------------------------------------------------------------
// aeOBB class
//------------------------------------------------------------------------------
class aeOBB
{
public:
  aeOBB() = default;
  aeOBB( const aeOBB& ) = default;
  aeOBB( const aeFloat4x4& transform );

  void SetTransform( const aeFloat4x4& transform );
  const aeFloat4x4& GetTransform() const;

  float GetMinDistance( aeFloat3 p ) const; // @TODO: GetDistanceFromSurface()
  bool IntersectRay( aeFloat3 p, aeFloat3 d, aeFloat3* pOut = nullptr, float* tOut = nullptr ) const;

  aeAABB GetAABB() const;

private:
  aeFloat4x4 m_transform;
  aeFloat4x4 m_invTransRot;
  aeAABB m_scaledAABB;
};

//------------------------------------------------------------------------------
// aeMath::RandomValue member functions
//------------------------------------------------------------------------------
template < typename T >
inline aeMath::RandomValue< T >::RandomValue( T min, T max ) : m_min(min), m_max(max) {}

template < typename T >
inline aeMath::RandomValue< T >::RandomValue( T value ) : m_min(value), m_max(value) {}

template < typename T >
inline void aeMath::RandomValue< T >::SetMin( T min )
{
  m_min = min;
}

template < typename T >
inline void aeMath::RandomValue< T >::SetMax( T max )
{
  m_max = max;
}

template < typename T >
inline T aeMath::RandomValue< T >::GetMin() const
{
  return m_min;
}

template < typename T >
inline T aeMath::RandomValue< T >::GetMax() const
{
  return m_max;
}

template < typename T >
inline T aeMath::RandomValue< T >::Get() const
{
  return Random( m_min, m_max );
}

template < typename T >
inline aeMath::RandomValue< T >::operator T() const
{
  return Get();
}

//------------------------------------------------------------------------------
// aeHash class (fnv1a)
// @NOTE: Empty strings and zero-length data buffers do not hash to zero
//------------------------------------------------------------------------------
class aeHash
{
public:
  aeHash() = default;
  explicit aeHash( uint32_t initialValue );

  aeHash& HashString( const char* str );
  aeHash& HashData( const uint8_t* data, const uint32_t length );

  void Set( uint32_t hash );
  uint32_t Get() const;

private:
  uint32_t m_hash = 0x811c9dc5;
};

#endif
//------------------------------------------------------------------------------
// aeAlloc.h
// Utilities for allocating objects. Provides functionality to track current and
// past allocations.
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEALLOC_H
#define AEALLOC_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

struct aeAllocInfo
{
  // Stats
  uint32_t GetAllocationsTotal() const;
  uint32_t GetDeallocationsTotal() const;
  uint32_t GetAllocationBytesTotal() const;
  uint32_t GetDeallocationBytesTotal() const;

  uint32_t GetAllocationsLength() const;
  const char* GetAllocationName( uint32_t index ) const;
  uint32_t GetAllocationCount( uint32_t index ) const;
  uint32_t GetAllocationBytes( uint32_t index ) const;

  uint32_t GetDeallocationsLength() const;
  const char* GetDeallocationName( uint32_t index ) const;
  uint32_t GetDeallocationCount( uint32_t index ) const;
  uint32_t GetDeallocationBytes( uint32_t index ) const;

  // Internal
  void Alloc( const char* typeName, uint32_t bytes );
  void Dealloc( const char* typeName, uint32_t bytes );
};
aeAllocInfo& GetAllocInfo();

#define _AE_ALLOC_DISABLE 0

//------------------------------------------------------------------------------
// aeAlloc
//------------------------------------------------------------------------------
namespace aeAlloc
{
  template < typename T >
  static T* Allocate();

  template < typename T >
  static T* AllocateArray( uint32_t count );

  template < typename T, typename ... Args >
  static T* Allocate( Args ... args );

  static uint8_t* AllocateRaw( uint32_t typeSize, uint32_t typeAlignment, uint32_t count );

  template < typename T >
  static void Release( T* obj );

  template < typename T >
  class Scratch
  {
  public:
    Scratch( uint32_t count )
    {
      m_count = count;
      m_data = AllocateArray< T >( count );
    }

    ~Scratch()
    {
      Release( m_data );
    }

    T* Data() { return m_data; }
    uint32_t Length() const { return m_count; }

    T& operator[] ( int32_t index ) { return m_data[ index ]; }
    const T& operator[] ( int32_t index ) const { return m_data[ index ]; }
    T& GetSafe( int32_t index ) { AE_ASSERT( index < (int32_t)m_count ); return m_data[ index ]; }
    const T& GetSafe( int32_t index ) const { AE_ASSERT( index < (int32_t)m_count ); return m_data[ index ]; }

  private:
    T* m_data;
    uint32_t m_count;
  };

  static const uint32_t kDefaultAlignment = 16;
  static const uint32_t kHeaderSize = 16;
  struct Header
  {
    uint32_t check;
    uint32_t count;
    uint32_t size;
    uint32_t typeSize;
  };
};

#if _AE_ALLOC_DISABLE
void PushArrayAlloc( void* );
bool PopArrayAlloc( void* );
#endif

//------------------------------------------------------------------------------
// aeAlloc member functions
//------------------------------------------------------------------------------
template < typename T >
T* aeAlloc::Allocate()
{
  return AllocateArray< T >( 1 );
}

template < typename T >
T* aeAlloc::AllocateArray( uint32_t count )
{
#if _AE_ALLOC_DISABLE
  T* result = new T[ count ];
  PushArrayAlloc( result );
  return result;

#else
  AE_STATIC_ASSERT( alignof( T ) <= kDefaultAlignment );
  AE_STATIC_ASSERT( sizeof( T ) % alignof( T ) == 0 ); // All elements in array should have correct alignment

  uint32_t size = kHeaderSize + sizeof( T ) * count;
  uint8_t* base = (uint8_t*)aeAlignedAlloc( size, kDefaultAlignment );
  AE_ASSERT( (intptr_t)base % kDefaultAlignment == 0 );
#if _AE_DEBUG_
  memset( (void*)base, 0xCD, size );
#endif

  AE_STATIC_ASSERT( sizeof( Header ) <= kHeaderSize );
  AE_STATIC_ASSERT( kHeaderSize % kDefaultAlignment == 0 );

  Header* header = (Header*)base;
  header->check = 0xABCD;
  header->count = count;
  header->size = size;
  header->typeSize = sizeof( T );

  T* result = (T*)( base + kHeaderSize );
  for ( uint32_t i = 0; i < count; i++ )
  {
    new( &result[ i ] ) T();
  }

#if _AE_DEBUG_
  GetAllocInfo().Alloc( aeGetTypeName< T >(), size );
#endif

  return result;
#endif
}

template < typename T, typename ... Args >
static T* aeAlloc::Allocate( Args ... args )
{
#if _AE_ALLOC_DISABLE
  return new T( args ... );
#else
  AE_STATIC_ASSERT( alignof( T ) <= kDefaultAlignment );

  uint32_t size = kHeaderSize + sizeof( T );
  uint8_t* base = (uint8_t*)aeAlignedAlloc( size, kDefaultAlignment );
  AE_ASSERT( (intptr_t)base % kDefaultAlignment == 0 );
#if _AE_DEBUG_
  memset( (void*)base, 0xCD, size );
#endif

  Header* header = (Header*)base;
  header->check = 0xABCD;
  header->count = 1;
  header->size = size;
  header->typeSize = sizeof( T );

#if _AE_DEBUG_
  GetAllocInfo().Alloc( aeGetTypeName< T >(), size );
#endif

  return new( (T*)( base + kHeaderSize ) ) T( args ... );
#endif
}

uint8_t* aeAlloc::AllocateRaw( uint32_t typeSize, uint32_t typeAlignment, uint32_t count )
{
#if _AE_ALLOC_DISABLE
  return AllocateArray< uint8_t >( count );
#else
  AE_ASSERT( typeAlignment );
  AE_ASSERT( typeAlignment <= kDefaultAlignment );
  AE_ASSERT( typeSize % typeAlignment == 0 ); // All elements in array should have correct alignment

  uint32_t size = kHeaderSize + typeSize * count;
  uint8_t* base = (uint8_t*)aeAlignedAlloc( size, kDefaultAlignment );
  AE_ASSERT( (intptr_t)base % kDefaultAlignment == 0 );
#if _AE_DEBUG_
  memset( (void*)base, 0xCD, size );
#endif

  Header* header = (Header*)base;
  header->check = 0xABCD;
  header->count = count;
  header->size = size;
  header->typeSize = typeSize;

#if _AE_DEBUG_
  GetAllocInfo().Alloc( "raw", size );
#endif

  return base + kHeaderSize;
#endif
}

template < typename T >
void aeAlloc::Release( T* obj )
{
  if ( !obj )
  {
    return;
  }

#if _AE_ALLOC_DISABLE
  if ( PopArrayAlloc( obj ) )
  {
    delete[] obj;
  }
  else
  {
    delete obj;
  }
#else
  AE_ASSERT( (intptr_t)obj % kDefaultAlignment == 0 );
  uint8_t* base = (uint8_t*)obj - kHeaderSize;

  Header* header = (Header*)( base );
  AE_ASSERT( header->check == 0xABCD );

  uint32_t count = header->count;
  AE_ASSERT_MSG( sizeof( T ) <= header->typeSize, "Released type T '#' does not match allocated type of size #", aeGetTypeName< T >(), header->typeSize );
  for ( uint32_t i = 0; i < count; i++ )
  {
    T* o = (T*)( (uint8_t*)obj + header->typeSize * i );
    o->~T();
  }

#if _AE_DEBUG_
  memset( (void*)base, 0xDD, header->size );
  GetAllocInfo().Dealloc( aeGetTypeName< T >(), header->size );
#endif

  aeAlignedFree( base );
#endif
}

#endif
//------------------------------------------------------------------------------
// aeArray.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AE_ARRAY_H
#define AE_ARRAY_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------
namespace AE_NAMESPACE {

//------------------------------------------------------------------------------
// Array class
//------------------------------------------------------------------------------
template < typename T >
class Array
{
public:
  Array();
  Array( uint32_t size ); // Reserve size (with length of 0)
  Array( uint32_t length, const T& val ); // Reserves 'length' and appends 'length' number of 'vals'
  Array( const Array< T >& other );
  ~Array();
  void operator =( const Array< T >& other );
  
  T& Append( const T& value );
  void Append( const T* values, uint32_t count );

  T& Insert( uint32_t index, const T& value );

  template < typename U > int32_t Find( const U& value ) const; // Returns -1 when not found
  template < typename Fn > int32_t FindFn( Fn testFn ) const; // Returns -1 when not found
  void Remove( uint32_t index );

  template < typename U > uint32_t RemoveAll( const U& value );
  template < typename Fn > uint32_t RemoveAllFn( Fn testFn );

  void Reserve( uint32_t total );
  void Clear();
  
  const T& operator[]( int32_t index ) const;
  T& operator[]( int32_t index );

  uint32_t Length() const;
  uint32_t Size() const;

  // Ranged-based loop
  T* begin() { return &m_array[ 0 ]; }
  T* end() { return &m_array[ m_length ]; }
  const T* begin() const { return &m_array[ 0 ]; }
  const T* end() const { return &m_array[ m_length ]; }

private:
  uint32_t m_GetNextSize() const;
  
  uint32_t m_length;
  uint32_t m_size;
  T* m_array;
};

//------------------------------------------------------------------------------
// Array ostream operator
//------------------------------------------------------------------------------
template < typename T >
inline std::ostream& operator<<( std::ostream& os, const Array< T >& array )
{
  os << "<";
  for ( uint32_t i = 0; i < array.Length(); i++ )
  {
    os << array[ i ];
    if ( i != array.Length() - 1 )
    {
      os << ", ";
    }
  }
  return os << ">";
}

//------------------------------------------------------------------------------
// Array member functions
//------------------------------------------------------------------------------
template < typename T >
Array< T >::Array()
{
  m_length = 0;
  m_size = 0;
  m_array = nullptr;
}

template < typename T >
Array< T >::Array( uint32_t size )
{
  m_length = 0;
  m_size = 0;
  m_array = nullptr;

  Reserve( size );
}

template < typename T >
Array< T >::Array( uint32_t length, const T& value )
{
  m_length = 0;
  m_size = 0;
  m_array = nullptr;

  Reserve( length );

  m_length = length;
  for ( uint32_t i = 0; i < length; i++ )
  {
    new ( &m_array[ i ] ) T ( value );
  }
}

template < typename T >
Array< T >::Array( const Array< T >& other )
{
  m_length = 0;
  m_size = 0;
  m_array = nullptr;
  
  // Array must be initialized above before calling Reserve
  Reserve( other.m_length );

  m_length = other.m_length;
  for ( uint32_t i = 0; i < m_length; i++ )
  {
    new ( &m_array[ i ] ) T ( other.m_array[ i ] );
  }
}

template < typename T >
Array< T >::~Array()
{
  Clear();
  
  aeAlloc::Release( (typename std::aligned_storage< sizeof(T), alignof(T) >::type*)m_array );
  m_size = 0;
  m_array = nullptr;
}

template < typename T >
void Array< T >::operator =( const Array< T >& other )
{
  if ( m_array == other.m_array )
  {
    return;
  }
  
  Clear();
  
  if ( m_size < other.m_length )
  {
    Reserve( other.m_length );
  }

  m_length = other.m_length;
  for ( uint32_t i = 0; i < m_length; i++ )
  {
    new ( &m_array[ i ] ) T ( other.m_array[ i ] );
  }
}

template < typename T >
T& Array< T >::Append( const T& value )
{
  if ( m_length == m_size )
  {
    Reserve( m_GetNextSize() );
  }

  new ( &m_array[ m_length ] ) T ( value );
  m_length++;

  return m_array[ m_length - 1 ];
}

template < typename T >
void Array< T >::Append( const T* values, uint32_t count )
{
  Reserve( m_length + count );

#if _AE_DEBUG_
  AE_ASSERT( m_size >= m_length + count );
#endif
  for ( uint32_t i = 0; i < count; i++ )
  {
    new ( &m_array[ m_length ] ) T ( values[ i ] );
    m_length++;
  }
}

template < typename T >
T& Array< T >::Insert( uint32_t index, const T& value )
{
#if _AE_DEBUG_
  AE_ASSERT( index <= m_length );
#endif

  if ( m_length == m_size )
  {
    Reserve( m_GetNextSize() );
  }

  if ( index == m_length )
  {
    new ( &m_array[ index ] ) T ( value );
  }
  else
  {
    new ( &m_array[ m_length ] ) T ( std::move( m_array[ m_length - 1 ] ) );
    for ( int32_t i = m_length - 1; i > index; i-- )
    {
      m_array[ i ] = std::move( m_array[ i - 1 ] );
    }
    m_array[ index ] = value;
  }
  
  m_length++;

  return m_array[ index ];
}

template < typename T >
void Array< T >::Remove( uint32_t index )
{
#if _AE_DEBUG_
  AE_ASSERT( index < m_length );
#endif

  m_length--;
  for ( uint32_t i = index; i < m_length; i++ )
  {
    m_array[ i ] = std::move( m_array[ i + 1 ] );
  }
  m_array[ m_length ].~T();
}

template < typename T >
template < typename U >
uint32_t Array< T >::RemoveAll( const U& value )
{
  uint32_t count = 0;
  int32_t index = 0;
  while ( ( index = Find( value ) ) >= 0 )
  {
    // @TODO: Update this to be single loop, so array is only compacted once
    Remove( index );
    count++;
  }
  return count;
}

template < typename T >
template < typename Fn >
uint32_t Array< T >::RemoveAllFn( Fn testFn )
{
  uint32_t count = 0;
  int32_t index = 0;
  while ( ( index = FindFn( testFn ) ) >= 0 )
  {
    // @TODO: Update this to be single loop, so array is only compacted once
    Remove( index );
    count++;
  }
  return count;
}

template < typename T >
template < typename U >
int32_t Array< T >::Find( const U& value ) const
{
  for ( uint32_t i = 0; i < m_length; i++ )
  {
    if ( m_array[ i ] == value )
    {
      return i;
    }
  }
  return -1;
}

template < typename T >
template < typename Fn >
int32_t Array< T >::FindFn( Fn testFn ) const
{
  for ( uint32_t i = 0; i < m_length; i++ )
  {
    if ( testFn( m_array[ i ] ) )
    {
      return i;
    }
  }
  return -1;
}

template < typename T >
void Array< T >::Reserve( uint32_t size )
{
  if ( size <= m_size )
  {
    return;
  }

  // Next power of two
  size--;
  size |= size >> 1;
  size |= size >> 2;
  size |= size >> 4;
  size |= size >> 8;
  size |= size >> 16;
  size++;

#if _AE_DEBUG_
  AE_ASSERT( size );
#endif
  m_size = size;

  T* arr = (T*)aeAlloc::AllocateArray< typename std::aligned_storage< sizeof(T), alignof(T) >::type >( m_size );
  for ( uint32_t i = 0; i < m_length; i++ )
  {
    new ( &arr[ i ] ) T ( std::move( m_array[ i ] ) );
    m_array[ i ].~T();
  }

  aeAlloc::Release( (typename std::aligned_storage< sizeof(T), alignof(T) >::type*)m_array );
  m_array = arr;
}

template < typename T >
void Array< T >::Clear()
{
  for ( uint32_t i = 0; i < m_length; i++ )
  {
    m_array[ i ].~T();
  }
  m_length = 0;
}

template < typename T >
const T& Array< T >::operator[]( int32_t index ) const
{
#if _AE_DEBUG_
  AE_ASSERT( index >= 0 );
  AE_ASSERT( index < (int32_t)m_length );
#endif
  return m_array[ index ];
}

template < typename T >
T& Array< T >::operator[]( int32_t index )
{
#if _AE_DEBUG_
  AE_ASSERT( index >= 0 );
  AE_ASSERT_MSG( index < (int32_t)m_length, "index: # length: #", index, m_length );
#endif
  return m_array[ index ];
}

template < typename T >
uint32_t Array< T >::Length() const
{
  return m_length;
}

template < typename T >
uint32_t Array< T >::Size() const
{
  return m_size;
}

template < typename T >
uint32_t Array< T >::m_GetNextSize() const
{
  if ( m_size == 0 )
  {
    return aeMath::Max( 1, 32 / sizeof(T) ); // @NOTE: Initially allocate 32 bytes (rounded down) of type
  }
  else
  {
    return m_size * 2;
  }
}

} // ae namespace end

// @TODO: Remove
#define aeArray ae::Array

#endif
//------------------------------------------------------------------------------
// aeString.h
// Fixed length string
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AESTRING_H
#define AESTRING_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Fixed length string definition
//------------------------------------------------------------------------------
template < uint32_t N >
class aeStr
{
public:
  aeStr();

  template < uint32_t N2 >
  aeStr( const aeStr<N2>& str );

  aeStr( const char* str );

  aeStr( uint32_t length, const char* str );

  aeStr( uint32_t length, char c );

  template < typename... Args >
  aeStr( const char* format, Args... args );

  explicit inline operator const char*() const;
  inline const char* c_str() const;

  template < uint32_t N2 >
  inline void operator =( const aeStr<N2>& str );

  inline aeStr<N> operator +( const char* str ) const;

  template < uint32_t N2 >
  inline aeStr<N> operator +( const aeStr<N2>& str ) const;

  inline void operator +=( const char* str );

  template < uint32_t N2 >
  inline void operator +=( const aeStr<N2>& str );

  template < uint32_t N2 >
  inline bool operator ==( const aeStr<N2>& str ) const;
  inline bool operator ==( const char* str ) const;

  template < uint32_t N2 >
  inline bool operator !=( const aeStr<N2>& str ) const;
  inline bool operator !=( const char* str ) const;

  template < uint32_t N2 >
  inline bool operator <( const aeStr<N2>& str ) const;
  inline bool operator <( const char* str ) const;

  template < uint32_t N2 >
  inline bool operator >( const aeStr<N2>& str ) const;
  inline bool operator >( const char* str ) const;

  template < uint32_t N2 >
  inline bool operator <=( const aeStr<N2>& str ) const;
  inline bool operator <=( const char* str ) const;

  template < uint32_t N2 >
  inline bool operator >=( const aeStr<N2>& str ) const;
  inline bool operator >=( const char* str ) const;

  inline char& operator[]( uint32_t i );
  inline const char operator[]( uint32_t i ) const;

  inline uint32_t Length() const;
  inline uint32_t Size() const;
  inline bool Empty() const;

  template < uint32_t N2 >
  inline void Append( const aeStr<N2>& str );
  inline void Append( const char* str );
  void Trim( uint32_t len );

  template < typename... Args >
  static aeStr< N > Format( const char* format, Args... args );

  static constexpr uint32_t MaxLength() { return N - 3u; } // Leave room for length far and null terminator
  template < uint32_t N2 > friend class aeStr;

private:
  template < uint32_t N2 > friend bool operator ==( const char*, const aeStr< N2 >& );
  template < uint32_t N2 > friend bool operator !=( const char*, const aeStr< N2 >& );
  template < uint32_t N2 > friend bool operator <( const char*, const aeStr< N2 >& );
  template < uint32_t N2 > friend bool operator >( const char*, const aeStr< N2 >& );
  template < uint32_t N2 > friend bool operator <=( const char*, const aeStr< N2 >& );
  template < uint32_t N2 > friend bool operator >=( const char*, const aeStr< N2 >& );
  template < uint32_t N2 > friend std::istream& operator>>( std::istream&, aeStr< N2 >& );

  void m_Format( const char* format );

  template < typename T, typename... Args >
  void m_Format( const char* format, T value, Args... args );

  uint16_t m_length;
  char m_str[ MaxLength() + 1u ];
};

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------
typedef aeStr< 16 > aeStr16;
typedef aeStr< 32 > aeStr32;
typedef aeStr< 64 > aeStr64;
typedef aeStr< 128 > aeStr128;
typedef aeStr< 256 > aeStr256;
typedef aeStr< 512 > aeStr512;

//------------------------------------------------------------------------------
// Non member functions
//------------------------------------------------------------------------------
template < uint32_t N >
std::ostream& operator<<( std::ostream& out, const aeStr< N >& str )
{
  return out << str.c_str();
}

template < uint32_t N >
std::istream& operator>>( std::istream& in, aeStr< N >& str )
{
  in.getline( str.m_str, aeStr< N >::MaxLength() );
  str.m_length = in.gcount();
  str.m_str[ str.m_length ] = 0;
  return in;
}

template < uint32_t N >
inline const aeStr< N >& ToString( const aeStr< N >& value )
{
  return value;
}

inline const char* ToString( const char* value )
{
  return value;
}

inline aeStr16 ToString( int32_t value )
{
  char str[ aeStr16::MaxLength() + 1u ];
  uint32_t length = snprintf( str, sizeof( str ) - 1, "%d", value );
  return aeStr16( length, str );
}

inline aeStr16 ToString( uint32_t value )
{
  char str[ aeStr16::MaxLength() + 1u ];
  uint32_t length = snprintf( str, sizeof( str ) - 1, "%u", value );
  return aeStr16( length, str );
}

inline aeStr16 ToString( float value )
{
  char str[ aeStr16::MaxLength() + 1u ];
  uint32_t length = snprintf( str, sizeof( str ) - 1, "%.2f", value );
  return aeStr16( length, str );
}

inline aeStr16 ToString( double value )
{
  char str[ aeStr16::MaxLength() + 1u ];
  uint32_t length = snprintf( str, sizeof( str ) - 1, "%.2f", value );
  return aeStr16( length, str );
}

template < typename T >
inline aeStr64 ToString( const T& v )
{
  std::stringstream os;
  os << v;
  return os.str().c_str();
}

//------------------------------------------------------------------------------
// aeStr member functions
//------------------------------------------------------------------------------
template < uint32_t N >
aeStr< N >::aeStr()
{
  AE_STATIC_ASSERT_MSG( sizeof( *this ) == N, "Incorrect aeStr size" );
  m_length = 0;
  m_str[ 0 ] = 0;
}

template < uint32_t N >
template < uint32_t N2 >
aeStr< N >::aeStr( const aeStr<N2>& str )
{
  AE_ASSERT( str.m_length <= (uint16_t)MaxLength() );
  m_length = str.m_length;
  memcpy( m_str, str.m_str, m_length + 1u );
}

template < uint32_t N >
aeStr< N >::aeStr( const char* str )
{
  m_length = (uint16_t)strlen( str );
  AE_ASSERT_MSG( m_length <= (uint16_t)MaxLength(), "Length:# Max:#", m_length, MaxLength() );
  memcpy( m_str, str, m_length + 1u );
}

template < uint32_t N >
aeStr< N >::aeStr( uint32_t length, const char* str )
{
  AE_ASSERT( length <= (uint16_t)MaxLength() );
  m_length = length;
  memcpy( m_str, str, m_length );
  m_str[ length ] = 0;
}

template < uint32_t N >
aeStr< N >::aeStr( uint32_t length, char c )
{
  AE_ASSERT( length <= (uint16_t)MaxLength() );
  m_length = length;
  memset( m_str, c, m_length );
  m_str[ length ] = 0;
}

template < uint32_t N >
template < typename... Args >
aeStr< N >::aeStr( const char* format, Args... args )
{
  m_length = 0;
  m_str[ 0 ] = 0;
  m_Format( format, args... );
}

template < uint32_t N >
inline aeStr< N >::operator const char*() const
{
  return m_str;
}

template < uint32_t N >
inline const char* aeStr< N >::c_str() const
{
  return m_str;
}

template < uint32_t N >
template < uint32_t N2 >
inline void aeStr< N >::operator =( const aeStr<N2>& str )
{
  AE_ASSERT( str.m_length <= (uint16_t)MaxLength() );
  m_length = str.m_length;
  memcpy( m_str, str.m_str, str.m_length + 1u );
}

template < uint32_t N >
inline aeStr<N> aeStr< N >::operator +( const char* str ) const
{
  aeStr<N> out( *this );
  out += str;
  return out;
}

template < uint32_t N >
template < uint32_t N2 >
inline aeStr<N> aeStr< N >::operator +( const aeStr<N2>& str ) const
{
  aeStr<N> out( *this );
  out += str;
  return out;
}

template < uint32_t N >
inline void aeStr< N >::operator +=( const char* str )
{
  uint32_t len = (uint32_t)strlen( str );
  AE_ASSERT( m_length + len <= (uint16_t)MaxLength() );
  memcpy( m_str + m_length, str, len + 1u );
  m_length += len;
}

template < uint32_t N >
template < uint32_t N2 >
inline void aeStr< N >::operator +=( const aeStr<N2>& str )
{
  AE_ASSERT( m_length + str.m_length <= (uint16_t)MaxLength() );
  memcpy( m_str + m_length, str.c_str(), str.m_length + 1u );
  m_length += str.m_length;
}

template < uint32_t N >
template < uint32_t N2 >
inline bool aeStr< N >::operator ==( const aeStr<N2>& str ) const
{
  return strcmp( m_str, str.c_str() ) == 0;
}

template < uint32_t N >
inline bool aeStr< N >::operator ==( const char* str ) const
{
  return strcmp( m_str, str ) == 0;
}

template < uint32_t N >
bool operator ==( const char* str0, const aeStr<N>& str1 )
{
  return strcmp( str0, str1.m_str ) == 0;
}

template < uint32_t N >
template < uint32_t N2 >
inline bool aeStr< N >::operator !=( const aeStr<N2>& str ) const
{
  return !operator==( str );
}

template < uint32_t N >
inline bool aeStr< N >::operator !=( const char* str ) const
{
  return !operator==( str );
}

template < uint32_t N >
bool operator !=( const char* str0, const aeStr<N>& str1 )
{
  return !operator==( str0, str1 );
}

template < uint32_t N >
template < uint32_t N2 >
inline bool aeStr< N >::operator <( const aeStr<N2>& str ) const
{
  return strcmp( m_str, str.c_str() ) < 0;
}

template < uint32_t N >
inline bool aeStr< N >::operator <( const char* str ) const
{
  return strcmp( m_str, str ) < 0;
}

template < uint32_t N >
bool operator <( const char* str0, const aeStr<N>& str1 )
{
  return strcmp( str0, str1.m_str ) < 0;
}

template < uint32_t N >
template < uint32_t N2 >
inline bool aeStr< N >::operator >( const aeStr<N2>& str ) const
{
  return strcmp( m_str, str.c_str() ) > 0;
}

template < uint32_t N >
inline bool aeStr< N >::operator >( const char* str ) const
{
  return strcmp( m_str, str ) > 0;
}

template < uint32_t N >
bool operator >( const char* str0, const aeStr<N>& str1 )
{
  return strcmp( str0, str1.m_str ) > 0;
}

template < uint32_t N >
template < uint32_t N2 >
inline bool aeStr< N >::operator <=( const aeStr<N2>& str ) const
{
  return strcmp( m_str, str.c_str() ) <= 0;
}

template < uint32_t N >
inline bool aeStr< N >::operator <=( const char* str ) const
{
  return strcmp( m_str, str ) <= 0;
}

template < uint32_t N >
bool operator <=( const char* str0, const aeStr<N>& str1 )
{
  return strcmp( str0, str1.m_str ) <= 0;
}

template < uint32_t N >
template < uint32_t N2 >
inline bool aeStr< N >::operator >=( const aeStr<N2>& str ) const
{
  return strcmp( m_str, str.c_str() ) >= 0;
}

template < uint32_t N >
inline bool aeStr< N >::operator >=( const char* str ) const
{
  return strcmp( m_str, str ) >= 0;
}

template < uint32_t N >
bool operator >=( const char* str0, const aeStr<N>& str1 )
{
  return strcmp( str0, str1.m_str ) >= 0;
}

template < uint32_t N >
inline char& aeStr< N >::operator[]( uint32_t i )
{
  AE_ASSERT( i <= m_length ); return m_str[ i ]; // @NOTE: Allow indexing null, one past length
}

template < uint32_t N >
inline const char aeStr< N >::operator[]( uint32_t i ) const
{
  AE_ASSERT( i <= m_length ); return m_str[ i ]; // @NOTE: Allow indexing null, one past length
}

template < uint32_t N >
inline uint32_t aeStr< N >::Length() const
{
  return m_length;
}

template < uint32_t N >
inline uint32_t aeStr< N >::Size() const
{
  return MaxLength();
}

template < uint32_t N >
inline bool aeStr< N >::Empty() const
{
  return m_length == 0;
}

template < uint32_t N >
template < uint32_t N2 >
inline void aeStr< N >::Append( const aeStr<N2>& str )
{
  *this += str;
}

template < uint32_t N >
inline void aeStr< N >::Append( const char* str )
{
  *this += str;
}

template < uint32_t N >
void aeStr< N >::Trim( uint32_t len )
{
  if ( len == m_length )
  {
    return;
  }

  AE_ASSERT( len < m_length );
  m_length = len;
  m_str[ m_length ] = 0;
}

template < uint32_t N >
template < typename... Args >
aeStr< N > aeStr< N >::Format( const char* format, Args... args )
{
  aeStr< N > result( "" );
  result.m_Format( format, args... );
  return result;
}

template < uint32_t N >
void aeStr< N >::m_Format( const char* format )
{
  *this += format;
}

template < uint32_t N >
template < typename T, typename... Args >
void aeStr< N >::m_Format( const char* format, T value, Args... args )
{
  if ( !*format )
  {
    return;
  }

  const char* head = format;
  while ( *head && *head != '#' )
  {
    head++;
  }
  if ( head > format )
  {
    *this += aeStr< N >( head - format, format );
  }

  if ( *head == '#' )
  {
    // @TODO: Replace with ToString()?
    std::ostringstream stream;
    stream << value;
    *this += stream.str().c_str();
    head++;
  }
  m_Format( head, args... );
}

#endif
//------------------------------------------------------------------------------
// aeAudio.h
// Platform specific defines
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEAUDIO_H
#define AEAUDIO_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeAudioData class
//------------------------------------------------------------------------------
class aeAudioData
{
public:
  aeAudioData();
  void Initialize( const char* filePath );
  void Destroy();

  aeStr64 name;
  uint32_t buffer;
  float length;
};

//------------------------------------------------------------------------------
// aeAudio class
//------------------------------------------------------------------------------
class aeAudio
{
public:
  void Initialize( uint32_t musicChannels, uint32_t sfxChannels );
  void Terminate();

  void SetVolume( float volume );

  void PlayMusic( const aeAudioData* audioFile, float volume, uint32_t channel );
  void PlaySfx( const aeAudioData* audioFile, float volume, int32_t priority ); // @NOTE: Lower priority values interrupt sfx with higher values

  void StopMusic( uint32_t channel );
  void StopAllSfx();

  uint32_t GetMusicChannelCount() const;
  uint32_t GetSfxChannelCount() const;

  void Log();

private:
  struct aeAudioChannel
  {
    uint32_t source = 0;
    int32_t priority = aeMath::MaxValue< int32_t >();
    const aeAudioData* resource = nullptr;
  };

  aeArray< aeAudioChannel > m_musicChannels;
  aeArray< aeAudioChannel > m_sfxChannels;
};

#endif
//------------------------------------------------------------------------------
// aeBinaryStream.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEBINARYSTREAM_H
#define AEBINARYSTREAM_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeBinaryStream class
//------------------------------------------------------------------------------
class aeBinaryStream
{
public:
  static aeBinaryStream Writer( uint8_t* data, uint32_t length );
  static aeBinaryStream Writer( aeArray< uint8_t >* array );
  static aeBinaryStream Writer();
  static aeBinaryStream Reader( const uint8_t* data, uint32_t length );
  static aeBinaryStream Reader( const aeArray< uint8_t >& data );

  void SerializeUint8( uint8_t& v );
  void SerializeUint8( const uint8_t& v );
  void SerializeUint16( uint16_t& v );
  void SerializeUint16( const uint16_t& v );
  void SerializeUint32( uint32_t& v );
  void SerializeUint32( const uint32_t& v );
  void SerializeUint64( uint64_t& v );
  void SerializeUint64( const uint64_t& v );

  void SerializeInt8( int8_t& v );
  void SerializeInt8( const int8_t& v );
  void SerializeInt16( int16_t& v );
  void SerializeInt16( const int16_t& v );
  void SerializeInt32( int32_t& v );
  void SerializeInt32( const int32_t& v );
  void SerializeInt64( int64_t& v );
  void SerializeInt64( const int64_t& v );

  void SerializeFloat( float& v );
  void SerializeFloat( const float& v );
  void SerializeDouble( double& v );
  void SerializeDouble( const double& v );

  void SerializeBool( bool& v );
  void SerializeBool( const bool& v );
  
  template < uint32_t N >
  void SerializeString( aeStr< N >& str );
  template < uint32_t N >
  void SerializeString( const aeStr< N >& str );

  template< typename T >
  void SerializeObject( T& v );
  template< typename T >
  void SerializeObject( const T& v );
  // Use SerializeObjectConditional() when an object may not be available for serialization when writing or reading. This function correctly updates read/write offsets when skipping serialization. Sends slightly more data than SerializeObject().
  template < typename T >
  void SerializeObjectConditional( T* obj );

  template< uint32_t N >
  void SerializeArray( char (&str)[ N ] );
  template< uint32_t N >
  void SerializeArray( const char (&str)[ N ] );
  void SerializeArray( aeArray< uint8_t>& array );
  void SerializeArray( const aeArray< uint8_t>& array );

  template< typename T >
  void SerializeRaw( T& v );
  template< typename T >
  void SerializeRaw( const T& v );
  void SerializeRaw( void* data, uint32_t length );
  void SerializeRaw( const void* data, uint32_t length );
  void SerializeRaw( aeArray< uint8_t >& array );
  void SerializeRaw( const aeArray< uint8_t >& array );

  // Once the stream is invalid serialization calls will result in silent no-ops
  void Invalidate() { m_isValid = false; }
  bool IsValid() const { return m_isValid; }
  
  // Get mode
  bool IsWriter() const { return m_mode == Mode::WriteBuffer; }
  bool IsReader() const { return m_mode == Mode::ReadBuffer; }

  // Get data buffer
  const uint8_t* GetData() const { return ( m_data || m_GetArray().Length() == 0 ) ? m_data : &m_GetArray()[ 0 ]; }
  uint32_t GetOffset() const { return m_offset; }
  uint32_t GetLength() const { return m_length; }

  // Get data past the current read head
  const uint8_t* PeekData() const { return GetData() + m_offset; }
  uint32_t GetRemaining() const { return m_length - m_offset; }
  void Discard( uint32_t length );

// @TODO: The following should be private, while making it clear that the above static functions
//        should be used instead of directly using a constructor.
// private:
  enum class Mode
  {
    None,
    ReadBuffer,
    WriteBuffer,
  };

  aeBinaryStream() = default;
  aeBinaryStream( Mode mode, uint8_t* data, uint32_t length );
  aeBinaryStream( Mode mode, const uint8_t* data, uint32_t length );
  aeBinaryStream( Mode mode );
  aeBinaryStream( aeArray< uint8_t >* array );

  aeArray< uint8_t >& m_GetArray() { return m_extArray ? *m_extArray : m_array; }
  const aeArray< uint8_t >& m_GetArray() const { return m_extArray ? *m_extArray : m_array; }

  Mode m_mode = Mode::None;
  bool m_isValid = false;
  uint8_t* m_data = nullptr;
  uint32_t m_length = 0;
  uint32_t m_offset = 0;
  aeArray< uint8_t >* m_extArray = nullptr;
  aeArray< uint8_t > m_array;

public:
  // Prevent the above functions from being called accidentally through automatic conversions
  template < typename T > void SerializeUint8( T ) = delete;
  template < typename T > void SerializeUint16( T ) = delete;
  template < typename T > void SerializeUint32( T ) = delete;
  template < typename T > void SerializeUint64( T ) = delete;
  template < typename T > void SerializeInt8( T ) = delete;
  template < typename T > void SerializeInt16( T ) = delete;
  template < typename T > void SerializeInt32( T ) = delete;
  template < typename T > void SerializeInt64( T ) = delete;
  template < typename T > void SerializeFloat( T ) = delete;
  template < typename T > void SerializeDouble( T ) = delete;
  template < typename T > void SerializeBool( T ) = delete;
  template < typename T > void SerializeString( T ) = delete;
};

//------------------------------------------------------------------------------
// aeBinaryStream member functions
//------------------------------------------------------------------------------
template < uint32_t N >
void aeBinaryStream::SerializeString( aeStr< N >& str )
{
  if ( IsWriter() )
  {
    const uint16_t len = str.Length();
    SerializeUint16( len );
    SerializeRaw( str.c_str(), len );
  }
  else if ( IsReader() )
  {
    uint16_t len = 0;
    SerializeUint16( len );
    if ( !IsValid() )
    {
      return;
    }

    if ( len > aeStr< N >::MaxLength() || GetRemaining() < len )
    {
      Invalidate();
    }
    else
    {
      str = aeStr< N >( len, (const char*)PeekData() );
      Discard( len );
    }
  }
}

template < uint32_t N >
void aeBinaryStream::SerializeString( const aeStr< N >& str )
{
  AE_ASSERT( m_mode == Mode::WriteBuffer );
  const uint16_t len = str.Length();
  SerializeUint16( len );
  SerializeRaw( str.c_str(), len );
}

template< typename T >
void aeBinaryStream_SerializeObjectInternal( aeBinaryStream* stream, T& v, decltype( &T::Serialize ) )
{
  v.Serialize( stream );
}

template< typename T >
void aeBinaryStream_SerializeObjectInternalConst( aeBinaryStream* stream, const T& v, decltype( &T::Serialize ) )
{
  v.Serialize( stream );
}

template< typename T >
void aeBinaryStream_SerializeObjectInternal( aeBinaryStream* stream, T& v, ... )
{
  Serialize( stream, &v );
}

template< typename T >
void aeBinaryStream_SerializeObjectInternalConst( aeBinaryStream* stream, const T& v, ... )
{
  Serialize( stream, &v );
}

template< typename T >
void aeBinaryStream::SerializeObject( T& v )
{
  aeBinaryStream_SerializeObjectInternal< T >( this, v, 0 );
}

template< typename T >
void aeBinaryStream::SerializeObject( const T& v )
{
  AE_ASSERT_MSG( m_mode == Mode::WriteBuffer, "Only write mode can be used when serializing a const type." );
  aeBinaryStream_SerializeObjectInternalConst< T >( this, v, 0 );
}

template< typename T >
void aeBinaryStream::SerializeRaw( T& v )
{
  if ( !m_isValid )
  {
    return;
  }
  else if ( m_mode == Mode::ReadBuffer )
  {
    AE_ASSERT( m_offset + sizeof(T) <= m_length );
    memcpy( &v, m_data + m_offset, sizeof(T) );
    m_offset += sizeof(T);
  }
  else if ( m_mode == Mode::WriteBuffer )
  {
    if ( m_data )
    {
      AE_ASSERT( sizeof(T) <= m_length - m_offset );
      memcpy( m_data + m_offset, &v, sizeof(T) );
      m_offset += sizeof(T);
    }
    else
    {
      aeArray< uint8_t >& array = m_GetArray();
      array.Append( (uint8_t*)&v, sizeof(T) );
      m_offset = array.Length();
      m_length = array.Size();
    }
  }
  else
  {
    AE_FAIL_MSG( "Binary stream must be initialized with aeBinaryStream::Writer or aeBinaryStream::Reader static functions." );
  }
}

template< typename T >
void aeBinaryStream::SerializeRaw( const T& v )
{
  AE_ASSERT_MSG( m_mode == Mode::WriteBuffer, "Only write mode can be used when serializing a const type." );
  SerializeRaw( *const_cast< T* >( &v ) );
}

template< uint32_t N >
void aeBinaryStream::SerializeArray( char (&str)[ N ] )
{
  uint16_t len = 0;
  if ( !m_isValid )
  {
    return;
  }
  else if ( m_mode == Mode::ReadBuffer )
  {
    AE_ASSERT( m_offset + sizeof(len) <= m_length ); // @TODO: Remove this and invalidate stream instead
    memcpy( &len, m_data + m_offset, sizeof(len) );
    m_offset += sizeof(len);

    AE_ASSERT( m_offset + len + 1 <= m_length ); // @TODO: Remove this and invalidate stream instead
    memcpy( str, m_data + m_offset, len );
    str[ len ] = 0;
    m_offset += len;
  }
  else if ( m_mode == Mode::WriteBuffer )
  {
    len = strlen( str );

    if ( m_data )
    {
      AE_ASSERT( sizeof(len) <= m_length - m_offset ); // @TODO: Remove this and invalidate stream instead
      memcpy( m_data + m_offset, &len, sizeof(len) );
      m_offset += sizeof(len);

      AE_ASSERT( len <= m_length - m_offset ); // @TODO: Remove this and invalidate stream instead
      memcpy( m_data + m_offset, str, len );
      m_offset += len;
    }
    else
    {
      aeArray< uint8_t >& array = m_GetArray();
      array.Append( (uint8_t*)&len, sizeof(len) );
      array.Append( (uint8_t*)&str, len );
      m_offset = array.Length();
      m_length = array.Size();
    }
  }
  else
  {
    AE_FAIL_MSG( "Binary stream must be initialized with aeBinaryStream::Writer or aeBinaryStream::Reader static functions." );
  }
}

template< uint32_t N >
void aeBinaryStream::SerializeArray( const char (&str)[ N ] )
{
  AE_ASSERT_MSG( m_mode == Mode::WriteBuffer, "Only write mode can be used when serializing a const array." );
  SerializeArray( const_cast< char[ N ] >( str ) );
}

template < typename T >
void aeBinaryStream::SerializeObjectConditional( T* obj )
{
  if ( !m_isValid )
  {
    return;
  }
  else if ( m_mode == Mode::ReadBuffer )
  {
    uint16_t length = 0;
    SerializeRaw( &length, sizeof( length ) );

    if ( length )
    {
      if ( obj )
      {
        // Read object
        uint32_t prevOffset = m_offset;
        SerializeObject( *obj );

        // Object should always read everything it wrote
        if ( prevOffset + length != m_offset )
        {
          Invalidate();
        }
      }
      else
      {
        Discard( length );
      }
    }
  }
  else if ( m_mode == Mode::WriteBuffer )
  {
    if ( obj )
    {
      // Reserve length
      uint32_t lengthOffset = m_offset;
      uint16_t lengthFake = 0xCDCD;
      SerializeRaw( &lengthFake, sizeof( lengthFake ) ); // Raw to avoid compression

      // Write object
      uint32_t prevOffset = m_offset;
      SerializeObject( *obj );

      // Rewrite previously serialized value
      uint32_t writeLength = m_offset - prevOffset;
      if ( writeLength > aeMath::MaxValue< uint16_t >() )
      {
        Invalidate(); // Object is too large to serialize
      }
      else if ( IsValid() ) // Can become invalid while writing by running out of memory
      {
        // @NOTE: Use length offset from above (and not a pointer into the data buffer) because the data buffer may not yet bet allocated or may be reallocated while serializing
        AE_ASSERT( GetData() );
        uint16_t* length = (uint16_t*)( GetData() + lengthOffset );
        AE_ASSERT( *length == 0xCDCD );
        *length = writeLength;
      }
    }
    else
    {
      uint16_t length = 0;
      SerializeRaw( &length, sizeof( length ) ); // Raw to avoid compression
    }
  }
  else
  {
    AE_FAIL_MSG( "Binary stream must be initialized with aeBinaryStream::Writer or aeBinaryStream::Reader static functions." );
  }
}

#endif
//------------------------------------------------------------------------------
// aeClock.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AECLOCK_H
#define AECLOCK_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeClock
//------------------------------------------------------------------------------
namespace aeClock
{
  double GetTime();
};

//------------------------------------------------------------------------------
// aeFixedTimeStep
//------------------------------------------------------------------------------
class aeFixedTimeStep
{
public:
  aeFixedTimeStep();

  void SetTimeStep( float timeStep ) { m_timeStepSec = timeStep; m_timeStep = timeStep * 1000000.0f; }
  float GetTimeStep() const { return m_timeStepSec; }
  float GetPrevFrameTime() const { return m_prevFrameTimeSec; }
  uint32_t GetStepCount() const { return m_stepCount; }
  
  void Wait();

private:
  uint32_t m_stepCount = 0;
  float m_timeStepSec = 0.0f;
  float m_timeStep = 0.0f;
  int64_t m_frameExcess = 0;
  float m_prevFrameTime = 0.0f;
  float m_prevFrameTimeSec = 0.0f;
  std::chrono::steady_clock::time_point m_frameStart;
};

//------------------------------------------------------------------------------
// aeTicker
//------------------------------------------------------------------------------
class aeTicker
{
public:
  aeTicker( double interval );
  bool Tick( double currentTime );

private:
  double m_interval;
  double m_accumulate;
};

#endif
//------------------------------------------------------------------------------
// Game.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AECOMMAND_H
#define AECOMMAND_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------
#include <vector>

//------------------------------------------------------------------------------
// Internal
//------------------------------------------------------------------------------
struct gdn_cmd
{
  struct cmd
  {
    char name[ 32 ];
    void (*fn)( void*, const char* );
  };
  static std::vector<cmd>& GetDefs()
  {
    static std::vector<cmd> defs;
    return defs;
  }
};

template< typename T >
inline T gdn_meta_type_parse( const char* str )
{
  return T();
};

template<>
inline int32_t gdn_meta_type_parse( const char* str )
{
  int32_t i = 0;
  sscanf( str, "%d", &i );
  return i;
};

template<>
inline uint32_t gdn_meta_type_parse( const char* str )
{
  uint32_t i = 0;
  sscanf( str, "%u", &i );
  return i;
};

template<>
inline float gdn_meta_type_parse( const char* str )
{
  float f = 0.0f;
  sscanf( str, "%f", &f );
  return f;
};

template<>
inline bool gdn_meta_type_parse( const char* str )
{
  if ( !str[ 0 ] )
  {
    // @NOTE: Default to true when no parameter is specified
    return true;
  }
  return gdn_meta_type_parse< int32_t >( str ) != 0;
};

template<>
inline const char* gdn_meta_type_parse( const char* str )
{
  return str;
};

template< typename R >
inline void gdn_run_cmd( void* data, R (*fn)( void* ), const char* params )
{
  fn( data );
}

template< typename R, typename P >
inline void gdn_run_cmd( void* data, R (*fn)( void*, P ), const char* params )
{
  char str[ 128 ];
  if ( strlcpy( str, params, countof(str) ) >= countof(str) )
  {
    return;
  }

  char* nextToken = nullptr;
  char* token = strtok_r( str, " ", &nextToken );
  if ( !token )
  {
    return;
  }

  fn( data, gdn_meta_type_parse< P >( token ) );
}

template< typename R, typename P0, typename P1 >
inline void gdn_run_cmd( void* data, R (*fn)( void*, P0, P1 ), const char* params )
{
  char str[ 128 ];
  if ( strlcpy( str, params, countof(str) ) >= countof(str) )
  {
    return;
  }

  char* nextToken = nullptr;
  char* token0 = strtok_r( str, " ", &nextToken );
  char* token1 = strtok_r( nullptr, " ", &nextToken );
  if ( !token0 || !token1 )
  {
    return;
  }

  P0 p0 = gdn_meta_type_parse< P0 >( token0 );
  P1 p1 = gdn_meta_type_parse< P1 >( token1 );
  fn( data, p0, p1 );
}

template< typename R, typename P0, typename P1, typename P2 >
inline void gdn_run_cmd( void* data, R (*fn)( void*, P0, P1, P2 ), const char* params )
{
  char str[ 128 ];
  if ( strlcpy( str, params, countof(str) ) >= countof(str) )
  {
    return;
  }

  char* nextToken = nullptr;
  char* token0 = strtok_r( str, " ", &nextToken );
  char* token1 = strtok_r( nullptr, " ", &nextToken );
  char* token2 = strtok_r( nullptr, " ", &nextToken );
  if ( !token0 || !token1 || !token2 )
  {
    return;
  }

  P0 p0 = gdn_meta_type_parse< P0 >( token0 );
  P1 p1 = gdn_meta_type_parse< P1 >( token1 );
  P2 p2 = gdn_meta_type_parse< P2 >( token2 );
  fn( data, p0, p1, p2 );
}

template< typename R, typename P0, typename P1, typename P2, typename P3 >
inline void gdn_run_cmd( void* data, R (*fn)( void*, P0, P1, P2, P3 ), const char* params )
{
  char str[ 128 ];
  if ( strlcpy( str, params, countof(str) ) >= countof(str) )
  {
    return;
  }

  char* nextToken = nullptr;
  char* token0 = strtok_r( str, " ", &nextToken );
  char* token1 = strtok_r( nullptr, " ", &nextToken );
  char* token2 = strtok_r( nullptr, " ", &nextToken );
  char* token3 = strtok_r( nullptr, " ", &nextToken );
  if ( !token0 || !token1 || !token2 || !token3 )
  {
    return;
  }

  P0 p0 = gdn_meta_type_parse< P0 >( token0 );
  P1 p1 = gdn_meta_type_parse< P1 >( token1 );
  P2 p2 = gdn_meta_type_parse< P2 >( token2 );
  P3 p3 = gdn_meta_type_parse< P3 >( token3 );
  fn( data, p0, p1, p2, p3 );
}

//------------------------------------------------------------------------------
// External
//------------------------------------------------------------------------------
#define AE_CMD( _x )                                              \
void gdn_exec_##_x( void* data, const char* params ) { gdn_run_cmd( data, _x, params ); } \
struct gdn_reg_meta_cmd_##_x {                                          \
  gdn_reg_meta_cmd_##_x() {                                             \
    gdn_cmd::cmd cmd;                                                   \
    strcpy( cmd.name, #_x );                                            \
    cmd.fn = gdn_exec_##_x;                                             \
    gdn_cmd::GetDefs().push_back( cmd );                                     \
  }};                                                                   \
gdn_reg_meta_cmd_##_x inst_gdn_reg_meta_cmd_##_x;

inline bool ae_call_cmd( void* data, const char* cmd )
{
  const char* nameEnd = strchr( cmd, ' ' );
  aeStr32 name = nameEnd ? aeStr32( nameEnd - cmd, cmd ) : aeStr32( cmd );
  uint32_t count = gdn_cmd::GetDefs().size();
  for ( uint32_t i = 0; i < count; i++ )
  {
    if ( name == gdn_cmd::GetDefs()[ i ].name )
    {
      gdn_cmd::GetDefs()[ i ].fn( data, nameEnd ? ( nameEnd + 1 ) : "" );
      return true;
    }
  }
  return false;
}

#endif
//------------------------------------------------------------------------------
// aeMap.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AE_MAP_H
#define AE_MAP_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------
namespace AE_NAMESPACE {

//------------------------------------------------------------------------------
// Map class
//------------------------------------------------------------------------------
template < typename K, typename V >
class Map
{
public:
  V& Set( const K& key, const V& value );
  V& Get( const K& key );
  const V& Get( const K& key ) const;
  const V& Get( const K& key, const V& defaultValue ) const;
  
  V* TryGet( const K& key );
  const V* TryGet( const K& key ) const;

  bool TryGet( const K& key, V* valueOut );
  bool TryGet( const K& key, V* valueOut ) const;
  
  bool Remove( const K& key );

  void Reserve( uint32_t total );
  void Clear();

  K& GetKey( uint32_t index );
  V& GetValue( uint32_t index );
  const K& GetKey( uint32_t index ) const;
  const V& GetValue( uint32_t index ) const;
  uint32_t Length() const;

private:
  template < typename K2, typename V2 >
  friend std::ostream& operator<<( std::ostream&, const Map< K2, V2 >& );

  struct Entry
  {
    Entry() = default;
    Entry( const K& k, const V& v );

    K key;
    V value;
  };

  int32_t m_FindIndex( const K& key ) const;

  Array< Entry > m_entries;
};

//------------------------------------------------------------------------------
// Map helper functions
//------------------------------------------------------------------------------
template < typename K >
bool Map_IsEqual( const K& k0, const K& k1 );

template <>
inline bool Map_IsEqual( const char* const & k0, const char* const & k1 )
{
  return strcmp( k0, k1 ) == 0;
}

template < typename K >
bool Map_IsEqual( const K& k0, const K& k1 )
{
  return k0 == k1;
}

//------------------------------------------------------------------------------
// Map member functions
//------------------------------------------------------------------------------
template < typename K, typename V >
Map< K, V >::Entry::Entry( const K& k, const V& v ) :
  key( k ),
  value( v )
{}

template < typename K, typename V >
int32_t Map< K, V >::m_FindIndex( const K& key ) const
{
  for ( uint32_t i = 0; i < m_entries.Length(); i++ )
  {
    if ( Map_IsEqual( m_entries[ i ].key, key ) )
    {
      return i;
    }
  }

  return -1;
}

template < typename K, typename V >
V& Map< K, V >::Set( const K& key, const V& value )
{
  int32_t index = m_FindIndex( key );
  Entry* entry = ( index >= 0 ) ? &m_entries[ index ] : nullptr;
  if ( entry )
  {
    return entry->value;
  }
  else
  {
    return m_entries.Append( Entry( key, value ) ).value;
  }
}

template < typename K, typename V >
V& Map< K, V >::Get( const K& key )
{
  return m_entries[ m_FindIndex( key ) ].value;
}

template < typename K, typename V >
const V& Map< K, V >::Get( const K& key ) const
{
  return m_entries[ m_FindIndex( key ) ].value;
}

template < typename K, typename V >
const V& Map< K, V >::Get( const K& key, const V& defaultValue ) const
{
  int32_t index = m_FindIndex( key );
  return ( index >= 0 ) ? m_entries[ index ].value : defaultValue;
}

template < typename K, typename V >
V* Map< K, V >::TryGet( const K& key )
{
  return const_cast< V* >( const_cast< const Map< K, V >* >( this )->TryGet( key ) );
}

template < typename K, typename V >
const V* Map< K, V >::TryGet( const K& key ) const
{
  int32_t index = m_FindIndex( key );
  if ( index >= 0 )
  {
    return &m_entries[ index ].value;
  }
  else
  {
    return nullptr;
  }
}

template < typename K, typename V >
bool Map< K, V >::TryGet( const K& key, V* valueOut )
{
  return const_cast< const Map< K, V >* >( this )->TryGet( key, valueOut );
}

template < typename K, typename V >
bool Map< K, V >::TryGet( const K& key, V* valueOut ) const
{
  const V* val = TryGet( key );
  if ( val )
  {
    if ( valueOut )
    {
      *valueOut = *val;
    }
    return true;
  }
  return false;
}

template < typename K, typename V >
bool Map< K, V >::Remove( const K& key )
{
  int32_t index = m_FindIndex( key );
  if ( index >= 0 )
  {
    m_entries.Remove( index );
    return true;
  }
  else
  {
    return false;
  }
}

template < typename K, typename V >
void Map< K, V >::Reserve( uint32_t total )
{
  m_entries.Reserve( total );
}

template < typename K, typename V >
void Map< K, V >::Clear()
{
  m_entries.Clear();
}

template < typename K, typename V >
K& Map< K, V >::GetKey( uint32_t index )
{
  return m_entries[ index ].key;
}

template < typename K, typename V >
V& Map< K, V >::GetValue( uint32_t index )
{
  return m_entries[ index ].value;
}

template < typename K, typename V >
const K& Map< K, V >::GetKey( uint32_t index ) const
{
  return m_entries[ index ].key;
}

template < typename K, typename V >
const V& Map< K, V >::GetValue( uint32_t index ) const
{
  return m_entries[ index ].value;
}

template < typename K, typename V >
uint32_t Map< K, V >::Length() const
{
  return m_entries.Length();
}

template < typename K, typename V >
std::ostream& operator<<( std::ostream& os, const Map< K, V >& map )
{
  os << "{";
  for ( uint32_t i = 0; i < map.m_entries.Length(); i++ )
  {
    os << "(" << map.m_entries[ i ].key << ", " << map.m_entries[ i ].value << ")";
    if ( i != map.m_entries.Length() - 1 )
    {
      os << ", ";
    }
  }
  return os << "}";
}

} // ae namespace end

// @TODO: Remove
#define aeMap ae::Map

#endif
//------------------------------------------------------------------------------
// aeRender.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AERENDER_H
#define AERENDER_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeRender constants
//------------------------------------------------------------------------------
const uint32_t kMaxShaderAttributeCount = 16;
const uint32_t kMaxShaderAttributeNameLength = 16;
const uint32_t kMaxShaderDefines = 4;

typedef uint32_t aeQuadIndex;
const uint32_t aeQuadVertCount = 4;
const uint32_t aeQuadIndexCount = 6;
extern const aeFloat3 aeQuadVertPos[ aeQuadVertCount ];
extern const aeFloat2 aeQuadVertUvs[ aeQuadVertCount ];
extern const aeQuadIndex aeQuadIndices[ aeQuadIndexCount ];

//------------------------------------------------------------------------------
// aeColor struct
//------------------------------------------------------------------------------
struct aeColor
{
  aeColor() {}
  aeColor( const aeColor& ) = default;
  aeColor( float rgb );
  aeColor( float r, float g, float b );
  aeColor( float r, float g, float b, float a );
  aeColor( aeColor c, float a );

  static aeColor R( uint8_t r );
  static aeColor RG( uint8_t r, uint8_t g );
  static aeColor RGB( uint8_t r, uint8_t g, uint8_t b );
  static aeColor RGBA( uint8_t r, uint8_t g, uint8_t b, uint8_t a );
  static aeColor R( float r );
  static aeColor RG( float r, float g );
  static aeColor RGB( float r, float g, float b );
  static aeColor RGBA( float r, float g, float b, float a );
  static aeColor RGBA( const float* v );
  static aeColor SRGB( float r, float g, float b );
  static aeColor SRGBA( float r, float g, float b, float a );
  static aeColor PS( uint8_t r, uint8_t g, uint8_t b, uint8_t a = 255 );

  // @TODO: Remove
  explicit operator aeFloat3() const { return aeFloat3( r, g, b ); }
  explicit operator aeFloat4() const { return aeFloat4( r, g, b, a ); }

  aeFloat3 GetLinearRGB() const { return aeFloat3( *this ); }
  aeFloat4 GetLinearRGBA() const { return aeFloat4( *this ); }
  aeFloat3 GetSRGB() const;
  aeFloat4 GetSRGBA() const;

  aeColor Lerp( const aeColor& end, float t ) const;
  aeColor DtLerp( float snappiness, float dt, const aeColor& target ) const;
  aeColor ScaleRGB( float s ) const { return aeColor( r * s, g * s, b * s, a ); }
  aeColor ScaleA( float s ) const { return aeColor( r, g, b, a * s ); }
  aeColor SetA( float alpha ) const { return aeColor( r, g, b, alpha ); }

  static float SRGBToRGB( float x );
  static float RGBToSRGB( float x );

  // Grayscale
  static aeColor White();
  static aeColor Gray();
  static aeColor Black();
  // Rainbow
  static aeColor Red();
  static aeColor Orange();
  static aeColor Yellow();
  static aeColor Green();
  static aeColor Blue();
  static aeColor Indigo();
  static aeColor Violet();
  // Pico
  static aeColor PicoBlack();
  static aeColor PicoDarkBlue();
  static aeColor PicoDarkPurple();
  static aeColor PicoDarkGreen();
  static aeColor PicoBrown();
  static aeColor PicoDarkGray();
  static aeColor PicoLightGray();
  static aeColor PicoWhite();
  static aeColor PicoRed();
  static aeColor PicoOrange();
  static aeColor PicoYellow();
  static aeColor PicoGreen();
  static aeColor PicoBlue();
  static aeColor PicoIndigo();
  static aeColor PicoPink();
  static aeColor PicoPeach();

  float r;
  float g;
  float b;
  float a;
};

inline std::ostream& operator<<( std::ostream& os, aeColor c )
{
  return os << "<" << c.r << ", " << c.g << ", " << c.b << ", " << c.a << ">";
}

//------------------------------------------------------------------------------
// aeVertex types
//------------------------------------------------------------------------------
struct aeVertexUsage
{
  enum Type
  {
    Dynamic,
    Static
  };
};

struct aeVertexDataType
{
  enum Type
  {
    UInt8,
    UInt16,
    UInt32,
    NormalizedUInt8,
    NormalizedUInt16,
    NormalizedUInt32,
    Float
  };
};

struct aeVertexPrimitive
{
  enum Type
  {
    Point,
    Line,
    Triangle
  };
};

struct aeVertexAttribute
{
  char name[ kMaxShaderAttributeNameLength ];
  uint32_t componentCount;
  uint32_t type; // GL_BYTE, GL_SHORT, GL_FLOAT...
  uint32_t offset;
  bool normalized;
};

//------------------------------------------------------------------------------
// aeUniformList class
//------------------------------------------------------------------------------
class aeUniformList
{
public:
  struct Value
  {
    uint32_t sampler = 0;
    uint32_t target = 0;
    int32_t size = 0;
    aeFloat4x4 value;
  };

  void Set( const char* name, float value );
  void Set( const char* name, aeFloat2 value );
  void Set( const char* name, aeFloat3 value );
  void Set( const char* name, aeFloat4 value );
  void Set( const char* name, const aeFloat4x4& value );
  void Set( const char* name, const class aeTexture* tex );

  const Value* Get( const char* name ) const;

private:
  aeMap< aeStr32, Value > m_uniforms;
};

//------------------------------------------------------------------------------
// aeVertexData class
//------------------------------------------------------------------------------
class aeVertexData
{
public:
  aeVertexData() = default;
  ~aeVertexData();

  void Initialize( uint32_t vertexSize, uint32_t indexSize, uint32_t maxVertexCount, uint32_t maxIndexCount, aeVertexPrimitive::Type primitive, aeVertexUsage::Type vertexUsage, aeVertexUsage::Type indexUsage );
  void AddAttribute( const char *name, uint32_t componentCount, aeVertexDataType::Type type, uint32_t offset );
  void Destroy();

  void SetVertices( const void* vertices, uint32_t count );
  void SetIndices( const void* indices, uint32_t count );
  
  const void* GetVertices() const;
  const void* GetIndices() const;
  uint32_t GetVertexSize() const { return m_vertexSize; }
  uint32_t GetIndexSize() const { return m_indexSize; }
  
  uint32_t GetVertexCount() const { return m_vertexCount; }
  uint32_t GetIndexCount() const { return m_indexCount; }
  uint32_t GetMaxVertexCount() const { return m_maxVertexCount; }
  uint32_t GetMaxIndexCount() const { return m_maxIndexCount; }
  uint32_t GetAttributeCount() const { return m_attributeCount; }
  aeVertexPrimitive::Type GetPrimitiveType() const { return m_primitive; }

  void Render( const class aeShader* shader, const aeUniformList& uniforms );
  void Render( const class aeShader* shader, uint32_t primitiveCount, const aeUniformList& uniforms );
  
private:
  aeVertexData( const aeVertexData& ) = delete;
  aeVertexData( aeVertexData&& ) = delete;
  void operator=( const aeVertexData& ) = delete;
  void operator=( aeVertexData&& ) = delete;

  void m_SetVertices( const void* vertices, uint32_t count );
  void m_SetIndices( const void* indices, uint32_t count );
  const aeVertexAttribute* m_GetAttributeByName( const char* name ) const;
  
  uint32_t m_array = 0;
  uint32_t m_vertices = ~0;
  uint32_t m_indices = ~0;
  uint32_t m_vertexCount = 0;
  uint32_t m_indexCount = 0;
  
  uint32_t m_maxVertexCount = 0;
  uint32_t m_maxIndexCount = 0;
  
  aeVertexPrimitive::Type m_primitive = (aeVertexPrimitive::Type)-1;
  aeVertexUsage::Type m_vertexUsage = (aeVertexUsage::Type)-1;
  aeVertexUsage::Type m_indexUsage = (aeVertexUsage::Type)-1;
  
  aeVertexAttribute m_attributes[ kMaxShaderAttributeCount ];
  uint32_t m_attributeCount = 0;
  uint32_t m_vertexSize = 0;
  uint32_t m_indexSize = 0;
  
  void* m_vertexReadable = nullptr;
  void* m_indexReadable = nullptr;
};

//------------------------------------------------------------------------------
// aeShader types
//------------------------------------------------------------------------------
struct aeShaderType
{
  enum Type
  {
    Vertex,
    Fragment
  };
};

struct aeShaderCulling
{
  enum Type
  {
    None,
    ClockwiseFront,
    CounterclockwiseFront,
  };
};

struct aeShaderAttribute
{
  char name[ kMaxShaderAttributeNameLength ];
  uint32_t type; // GL_FLOAT, GL_FLOAT_VEC4, GL_FLOAT_MAT4...
  int32_t location;
};

struct aeShaderUniform
{
  aeStr32 name;
  uint32_t type;
  int32_t location;
};

//------------------------------------------------------------------------------
// aeShader class
// @NOTE: Some special built in functions and defines are automatically included
//        for portability reasons (e.g. for OpenGL ES). There are also some
//        convenient helper functions to convert between linear and srgb color
//        spaces. It's not necessary to use any of these helpers and basic valid
//        GLSL can be provided instead.
//------------------------------------------------------------------------------
// Example vertex shader
/*
AE_UNIFORM_HIGHP mat4 u_worldToScreen;

AE_IN_HIGHP vec3 a_position;
AE_IN_HIGHP vec2 a_uv;
AE_IN_HIGHP vec4 a_color;

AE_OUT_HIGHP vec2 v_uv;
AE_OUT_HIGHP vec4 v_color;

void main()
{
  v_uv = a_uv;
  v_color = a_color;
  gl_Position = u_worldToScreen * vec4( a_position, 1.0 );
}
*/
// Example fragment shader
/*
AE_UNIFORM sampler2D u_tex;

AE_IN_HIGHP vec2 v_uv;
AE_IN_HIGHP vec4 v_color;

void main()
{
  AE_COLOR = AE_RGBA_TO_SRGBA( AE_SRGBA_TO_RGBA( AE_TEXTURE2D( u_tex, v_uv ) ) * v_color );
}
*/
class aeShader
{
public:
  aeShader();
  ~aeShader();
  
  void Initialize( const char* vertexStr, const char* fragStr, const char* const* defines, int32_t defineCount );
  void Destroy();

  void SetBlending( bool enabled ) { m_blending = enabled; }
  void SetDepthTest( bool enabled ) { m_depthTest = enabled; }
  void SetDepthWrite( bool enabled ) { m_depthWrite = enabled; }
  void SetCulling( aeShaderCulling::Type culling ) { m_culling = culling; }
  void SetWireframe( bool enabled ) { m_wireframe = enabled; }
  void SetBlendingPremul( bool enabled ) { m_blendingPremul = enabled; }
	
private:
  int m_LoadShader( const char* shaderStr, aeShaderType::Type type, const char* const* defines, int32_t defineCount );
  
  uint32_t m_fragmentShader;
  uint32_t m_vertexShader;
  uint32_t m_program;

  bool m_blending;
  bool m_blendingPremul;
  bool m_depthTest;
  bool m_depthWrite;
  aeShaderCulling::Type m_culling;
  bool m_wireframe;
  
  aeShaderAttribute m_attributes[ kMaxShaderAttributeCount ];
  uint32_t m_attributeCount;

  aeMap< aeStr32, aeShaderUniform > m_uniforms;

public:
  // Internal
  void Activate( const aeUniformList& uniforms ) const;
  const aeShaderAttribute* GetAttributeByIndex( uint32_t index ) const;
  uint32_t GetAttributeCount() const { return m_attributeCount; }
};

//------------------------------------------------------------------------------
// aeTexture
//------------------------------------------------------------------------------
struct aeTextureFilter
{
  enum Type
  {
    Linear,
    Nearest
  };
};

struct aeTextureWrap
{
  enum Type
  {
    Repeat,
    Clamp
  };
};

struct aeTextureFormat
{
  enum Type
  {
	  Depth32F,
	  
	  R8, // unorm
	  R16_UNORM, // for height fields
	  R16F,
	  R32F,
	  
	  RG8, // unorm
	  RG16F,
	  RG32F,
	  
	  RGB8, // unorm
	  RGB8_SRGB,
	  RGB16F,
	  RGB32F,
	  
	  RGBA8, // unorm
	  RGBA8_SRGB,
	  RGBA16F,
	  RGBA32F,
	
	// non-specific formats, prefer specific types above
    R = RGBA8,
	RG = RG8,
    RGB = RGB8,
    RGBA = RGBA8,
	  
	Depth = Depth32F,
	  
    // TODO: these formats are implemented for OSX only for now
	SRGB = RGB8_SRGB,
    SRGBA = RGBA8_SRGB,
  };
};

struct aeTextureType
{
  enum Type
  {
    Uint8,
	Uint16,
    HalfFloat,
    Float
  };
};

class aeTexture
{
public:
  aeTexture() = default;
  virtual ~aeTexture();

  void Initialize( uint32_t target );
  virtual void Destroy();

  uint32_t GetTexture() const { return m_texture; }
  uint32_t GetTarget() const { return m_target; }

private:
  aeTexture( const aeTexture& ) = delete;
  aeTexture( aeTexture&& ) = delete;
  void operator=( const aeTexture& ) = delete;
  void operator=( aeTexture&& ) = delete;

  uint32_t m_texture = 0;
  uint32_t m_target = 0;
};

class aeTexture2D : public aeTexture
{
public:
  void Initialize( const void* data, uint32_t width, uint32_t height, aeTextureFormat::Type format, aeTextureType::Type type, aeTextureFilter::Type filter, aeTextureWrap::Type wrap, bool autoGenerateMipmaps = false );
  void Initialize( const char* file, aeTextureFilter::Type filter, aeTextureWrap::Type wrap, bool autoGenerateMipmaps = false,
	  bool isSRGB = false );
  void Destroy() override;

  uint32_t GetWidth() const { return m_width; }
  uint32_t GetHeight() const { return m_height; }

private:
  uint32_t m_width = 0;
  uint32_t m_height = 0;
  bool m_hasAlpha = false;
};

class aeRenderTarget
{
public:
  ~aeRenderTarget();
  void Initialize( uint32_t width, uint32_t height );
  void AddTexture( aeTextureFilter::Type filter, aeTextureWrap::Type wrap );
  void AddDepth( aeTextureFilter::Type filter, aeTextureWrap::Type wrap );
  void Destroy();

  void Activate();
  void Clear( aeColor color );
  void Render( const aeShader* shader, const aeUniformList& uniforms );
  void Render2D( uint32_t textureIndex, aeRect ndc, float z );

  const aeTexture2D* GetTexture( uint32_t index ) const;
  const aeTexture2D* GetDepth() const;
  uint32_t GetWidth() const;
  uint32_t GetHeight() const;

  // @NOTE: Get ndc space rect of this target within another target (fill but maintain aspect ratio)
  // GetNDCFillRectForTarget( aeRender::GetWindow()::GetWidth(),  aeRender::GetWindow()::Height() )
  // GetNDCFillRectForTarget( aeRenderTarget()::GetWidth(),  aeRenderTarget()::Height() )
  aeRect GetNDCFillRectForTarget( uint32_t otherWidth, uint32_t otherHeight ) const;

  // @NOTE: Other target to local transform (pixels->pixels)
  // Useful for transforming window/mouse pixel coordinates to local pixels
  // GetTargetPixelsToLocalTransform( aeRender::GetWindow()::GetWidth(),  aeRender::GetWindow()::Height(), GetNDCFillRectForTarget( ... ) )
  aeFloat4x4 GetTargetPixelsToLocalTransform( uint32_t otherPixelWidth, uint32_t otherPixelHeight, aeRect ndc ) const;

  // @NOTE: Mouse/window pixel coordinates to world space
  // GetTargetPixelsToWorld( GetTargetPixelsToLocalTransform( ... ), TODO )
  aeFloat4x4 GetTargetPixelsToWorld( const aeFloat4x4& otherTargetToLocal, const aeFloat4x4& worldToNdc ) const;

  // @NOTE: Creates a transform matrix from aeQuad vertex positions to ndc space
  // aeRenderTarget uses aeQuad vertices internally
  static aeFloat4x4 GetQuadToNDCTransform( aeRect ndc, float z );

private:
  struct Vertex
  {
    aeFloat3 pos;
    aeFloat2 uv;
  };

  uint32_t m_fbo = 0;

  aeArray< aeTexture2D* > m_targets;
  aeTexture2D m_depth;

  uint32_t m_width = 0;
  uint32_t m_height = 0;

  aeVertexData m_quad;
  aeShader m_shader;
};

//------------------------------------------------------------------------------
// aeSpriteRender class
//------------------------------------------------------------------------------
class aeSpriteRender
{
public:
  aeSpriteRender();
  void Initialize( uint32_t maxCount );
  void Destroy();
  // @TODO: change name to ndc space or remove and just use AddSprite transform
  void Render( const aeFloat4x4& worldToScreen );

  void SetBlending( bool enabled );
  void SetDepthTest( bool enabled );
  void SetDepthWrite( bool enabled );
  void SetSorting( bool enabled );

  // @NOTE: Each sprite is also transformed by the Render( worldToScreen ) above
  void AddSprite( const aeTexture2D* texture, aeFloat4x4 transform, aeFloat2 uvMin, aeFloat2 uvMax, aeColor color );
  void Clear();

private:
  void m_Render( const aeFloat4x4& worldToScreen, aeShader* shader );
  void m_LoadShaderAll();
  void m_LoadShaderOpaque();
  void m_LoadShaderTransparent();
  
  struct Vertex
  {
    aeFloat3 pos;
    aeFloat4 color;
    aeFloat2 uv;
  };

  struct Sprite
  {
    aeFloat4x4 transform;
    aeFloat2 uvMin;
    aeFloat2 uvMax;
    aeColor color;
    uint32_t textureId;
    float sort;
  };

  uint32_t m_count;
  uint32_t m_maxCount;
  Sprite* m_sprites;
  aeVertexData m_vertexData;
  aeShader* m_shaderAll;
  aeShader* m_shaderOpaque;
  aeShader* m_shaderTransparent;
  aeMap< const aeTexture2D*, uint32_t > m_textures;
  
  bool m_blending;
  bool m_depthTest;
  bool m_depthWrite;
  bool m_sorting;
};

//------------------------------------------------------------------------------
// aeTextRender class
//------------------------------------------------------------------------------
class aeTextRender
{
public:
  // @NOTE: 'imagePath' should be the path to a square texture with ascii
  //        characters evenly spaced from top left to bottom right. The
  //        texture can be a single channel without transparency. Luminance
  //        of the red channel is used for transparency.
  //        'charSize' is the width and height of each character in the texture.
  void Initialize( const char* imagePath, aeTextureFilter::Type filterType, uint32_t fontSize ); // @TODO: Text render should take a texture and the user should handle file loading
  void Terminate();
  void Render( const aeFloat4x4& uiToScreen );

  uint32_t GetFontSize() const { return m_fontSize; }

  void Add( aeFloat3 pos, aeFloat2 size, const char* str, aeColor color, uint32_t lineLength, uint32_t charLimit );
  uint32_t GetLineCount( const char* str, uint32_t lineLength, uint32_t charLimit ) const;

private:
  uint32_t m_ParseText( const char* str, uint32_t lineLength, uint32_t charLimit, aeStr512* outText ) const;

  static const uint32_t kMaxTextRects = 32;

  struct Vertex
  {
    aeFloat3 pos;
    aeFloat2 uv;
    aeColor color;
  };

  struct TextRect
  {
    aeStr512 text;
    aeFloat3 pos;
    aeFloat2 size;
    aeColor color;
  };

  uint32_t m_fontSize;

  aeVertexData m_vertexData;
  aeShader m_shader;
  aeTexture2D m_texture;

  uint32_t m_rectCount;
  TextRect m_rects[ kMaxTextRects ];
};

//------------------------------------------------------------------------------
// aeDebugRender class
//------------------------------------------------------------------------------
class aeDebugRender
{
public:
  void Initialize();
  void Destroy();
  void Render( const aeFloat4x4& worldToScreen );
  void Clear();

  void AddLine( aeFloat3 p0, aeFloat3 p1, aeColor color );
  void AddDistanceCheck( aeFloat3 p0, aeFloat3 p1, float distance );

  void AddRect( aeFloat3 pos, aeFloat3 up, aeFloat3 normal, aeFloat2 size, aeColor color );
  void AddCircle( aeFloat3 pos, aeFloat3 normal, float radius, aeColor color, uint32_t pointCount );

  void AddSphere( aeFloat3 pos, float radius, aeColor color, uint32_t pointCount );
  void AddAABB( aeFloat3 pos, aeFloat3 halfSize, aeColor color );
  void AddCube( aeFloat4x4 transform, aeColor color );

private:
  static const uint32_t kMaxDebugObjects = 128;

  struct DebugVertex
  {
    aeFloat3 pos;
    aeColor color;
  };
  aeArray< DebugVertex > m_verts;
  aeVertexData m_vertexData;
  aeShader m_shader;

  enum class DebugType
  {
    Line,
    Rect,
    Circle,
    Sphere,
    AABB,
    Cube,
  };

  struct DebugObject
  {
    DebugType type;
    aeFloat3 pos;
    aeFloat3 end;
    aeQuat rotation;
    aeFloat3 size;
    float radius;
    aeColor color;
    uint32_t pointCount; // circle only
    aeFloat4x4 transform;
  };
  uint32_t m_objCount;
  DebugObject m_objs[ kMaxDebugObjects ];
};

//------------------------------------------------------------------------------
// aeRender class
//------------------------------------------------------------------------------
class aeRender
{
public:
  aeRender();
  ~aeRender();

  void InitializeOpenGL( class aeWindow* window );
  void Terminate();

  void Activate();
  void Clear( aeColor color );
  void Present();

  class aeWindow* GetWindow() { return m_window; }
  aeRenderTarget* GetCanvas() { return &m_canvas; }

  uint32_t GetWidth() const { return m_width; }
  uint32_t GetHeight() const { return m_height; }
  float GetAspectRatio() const;

  // this is so imgui and the main render copy can enable srgb writes in (GL only)
  void EnableSRGBWrites( bool enable );
	
  // have to inject a barrier to readback from active render target (GL only)
  void AddTextureBarrier();

private:
  class aeRenderInternal* m_renderInternal;

  class aeWindow* m_window;
  uint32_t m_width;
  uint32_t m_height;

  aeRenderTarget m_canvas;
};

#endif
//------------------------------------------------------------------------------
// aeDict.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEDICT_H
#define AEDICT_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeDict class
//------------------------------------------------------------------------------
class aeDict
{
public:
  void SetString( const char* key, const char* value );
  void SetInt( const char* key, int32_t value );
  void SetFloat( const char* key, float value );
  void SetBool( const char* key, bool value );
  void SetFloat2( const char* key, aeFloat2 value );
  void SetFloat3( const char* key, aeFloat3 value );
  void SetFloat4( const char* key, aeFloat4 value );
  void SetInt2( const char* key, aeInt2 value );
  void Clear();

  const char* GetString( const char* key, const char* defaultValue ) const;
  int32_t GetInt( const char* key, int32_t defaultValue ) const;
  float GetFloat( const char* key, float defaultValue ) const;
  bool GetBool( const char* key, bool defaultValue ) const;
  aeFloat2 GetFloat2( const char* key, aeFloat2 defaultValue ) const;
  aeFloat3 GetFloat3( const char* key, aeFloat3 defaultValue ) const;
  aeFloat4 GetFloat4( const char* key, aeFloat4 defaultValue ) const;
  aeInt2 GetInt2( const char* key, aeInt2 defaultValue ) const;
  aeColor GetColor( const char* key, aeColor defaultValue ) const;
  bool Has( const char* key ) const;

  const char* GetKey( uint32_t idx ) const;
  const char* GetValue( uint32_t idx ) const;
  uint32_t Length() const { return m_entries.Length(); }
  
  // Supported automatic conversions which would otherwise be deleted below
  void SetString( const char* key, char* value ) { SetString( key, (const char*)value ); }
  void SetInt( const char* key, uint32_t value ) { SetInt( key, (int32_t)value ); }
  void SetFloat( const char* key, double value ) { SetFloat( key, (float)value ); }

private:
  // Prevent the above functions from being called accidentally through automatic conversions
  template < typename T > void SetString( const char*, T ) = delete;
  template < typename T > void SetInt( const char*, T ) = delete;
  template < typename T > void SetFloat( const char*, T ) = delete;
  template < typename T > void SetBool( const char*, T ) = delete;
  template < typename T > void SetFloat2( const char*, T ) = delete;
  template < typename T > void SetFloat3( const char*, T ) = delete;
  template < typename T > void SetFloat4( const char*, T ) = delete;
  template < typename T > void SetInt2( const char*, T ) = delete;
  
  aeMap< aeStr128, aeStr128 > m_entries;
};

std::ostream& operator<<( std::ostream& os, const aeDict& dict );

#endif
//------------------------------------------------------------------------------
// aeCommandLineArgs.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AECOMMANDLINEARGS_H
#define AECOMMANDLINEARGS_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------
const uint32_t kMaxCommandLineArgs = 16;

//------------------------------------------------------------------------------
// aeCommandLineArgs
//------------------------------------------------------------------------------
class aeCommandLineArgs
{
public:
  aeCommandLineArgs();
  void Parse( int32_t argc, char* argv[] );

  aeDict Get() const;
  uint32_t Count() const { return m_count; }
  const char* GetName( uint32_t index ) const;
  const char* GetValue( uint32_t index ) const;
  const char* GetValue( const char* name ) const;
  bool Has( const char* name ) const;

private:
  aeStr32 m_names[ kMaxCommandLineArgs ];
  aeStr128 m_values[ kMaxCommandLineArgs ];
  uint32_t m_count;
};

#endif
//------------------------------------------------------------------------------
// aeCompactingAllocator.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AECOMPACTINGALLOCATOR_H
#define AECOMPACTINGALLOCATOR_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeCompactingAllocator class
// @NOTE: 'p's must remain valid and writable until Free() is called.
//        'p's will be rewritten to maintain zero internal fragmentation.
//------------------------------------------------------------------------------
class aeCompactingAllocator
{
public:
  aeCompactingAllocator() = default;
  aeCompactingAllocator( uint32_t bytes );
  void Expand( uint32_t totalBytes );
  ~aeCompactingAllocator();

  template < typename T >
  void Allocate( T** p, uint32_t size );
  
  //template < typename T >
  //void Reallocate( T** p, uint32_t size );
  
  template < typename T >
  void Free( T** p );
  
private:
  const static intptr_t kAlignment = 16; // @TODO: Should be configurable

  struct Header
  {
    uint32_t check;
    uint16_t size;
    Header* next;
    Header* prev;
    void** external;
    uint32_t dbgTypeId;

    uint8_t pad[ 24 ];
  };

  void m_Compact();
  Header* m_GetHeader( void* p );
  void m_Verify();

  bool m_isCompact = true;
  uint8_t* m_data = nullptr;
  Header* m_tail = nullptr;
  uint32_t m_size = 0;
};

//------------------------------------------------------------------------------
// aeCompactingAllocator templated member functions
//------------------------------------------------------------------------------
template < typename T >
void aeCompactingAllocator::Allocate( T** _p, uint32_t size )
{
  AE_ASSERT( m_data );
  AE_STATIC_ASSERT( std::is_pod< T >::value );
  AE_STATIC_ASSERT( alignof( T ) <= kAlignment );
  void** p = (void**)_p;

  // Move all allocations to front of m_data
  m_Compact();

  // Always append newest allocation to end
  if ( m_tail )
  {
    Header* next = (Header*)( (uint8_t*)m_tail + sizeof( Header ) + m_tail->size );
    AE_ASSERT( (uint8_t*)next - m_data + size + sizeof( Header ) < m_size ); // @TODO: Should return null
    next->size = size;
    next->next = nullptr;
    next->external = p;
    next->dbgTypeId = aeHash().HashString( aeGetTypeName< T >() ).Get();
    next->check = 0xABABABAB;
    *p = (uint8_t*)next + sizeof( Header );
    next->prev = m_tail;
    m_tail->next = next;
    m_tail = next;
  }
  else
  {
    m_tail = (Header*)m_data;
    m_tail->size = size;
    m_tail->next = nullptr;
    m_tail->prev = nullptr;
    m_tail->external = p;
    m_tail->dbgTypeId = aeHash().HashString( aeGetTypeName< T >() ).Get();
    m_tail->check = 0xABABABAB;
    *p = (uint8_t*)m_tail + sizeof( Header );
  }

  //AE_LOG( "sizeof(Header):#", sizeof( Header ) );
  //AE_ASSERT_MSG( (intptr_t)*p % kAlignment == 0, "Allocation alignment: #", (intptr_t)*p % kAlignment );

  m_Verify();

  //AE_LOG( "Allocate #", *p );
}

//void aeCompactingAllocator::Reallocate( void** p, uint32_t size )
//{
//  AE_ASSERT( m_data );
//
//  m_Compact();
//
//  Header* oldHeader = m_GetHeader( p );
//  if ( oldHeader->size > size )
//  {
//    oldHeader->size = size;
//  }
//  else if ( oldHeader->size < size )
//  {
//    Header* newHeader = (Header*)( (uint8_t*)m_tail + sizeof( Header ) + m_tail->size );
//    AE_ASSERT( (uint8_t*)newHeader - m_data + size + sizeof( Header ) < m_size );
//    memmove( newHeader, oldHeader, sizeof( Header ) + oldHeader->size );
//    *( newHeader->external ) = (uint8_t*)newHeader + sizeof( Header );
//    newHeader->size = size;
//    newHeader->next = nullptr;
//    newHeader->prev = m_tail;
//    m_tail->next = newHeader;
//    m_tail = newHeader;
//  }
//}

template < typename T >
void aeCompactingAllocator::Free( T** p )
{
  AE_ASSERT( p );
  if ( *p == nullptr )
  {
    return;
  }

  //AE_LOG( "Free #", *p );

  AE_ASSERT( m_data );
  AE_ASSERT( m_data < (uint8_t*)*p );
  AE_ASSERT( (uint8_t*)*p < m_data + m_size );

  Header* header = m_GetHeader( (void*)*p );
  uint32_t typeHash = aeHash().HashString( aeGetTypeName< T >() ).Get();
  AE_ASSERT_MSG( header->dbgTypeId == typeHash, "Type mismatch between allocation and free" );
  *(header->external) = nullptr;
  header->external = nullptr;

  // Always flag for compaction, even if only to reclaim empty tail headers
  m_isCompact = false;

  m_Verify();
}

#endif
//------------------------------------------------------------------------------
// aeEditorCamera.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEEDITORCAMERA_H
#define AEEDITORCAMERA_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeEditorCamera class
//------------------------------------------------------------------------------
class aeEditorCamera
{
public:
	enum class Mode
	{
		None,
		Rotate,
		Pan,
		Zoom,
	};
	
	aeEditorCamera();
	void Update( const class aeInput* input, float dt ); // @TODO: This should take input values, not the whole input system

	void Reset( aeFloat3 focus, aeFloat3 pos ); // Interupts refocus. Does not affect input mode.
	void SetDistanceFromFocus( float distance ); // Updates position. Does not affect input mode or refocus.
	void Refocus( aeFloat3 focus ); // Updates focus and position over time
	void SetInputEnabled( bool enabled ); // True by default

	Mode GetMode() const { return m_mode; }
	aeFloat3 GetPosition() const { return m_focusPos + m_offset; }
	aeFloat3 GetFocus() const { return m_focusPos; }
	aeFloat3 GetForward() const { return m_forward; }
	float GetDistanceFromFocus() const { return m_dist; }

private:
	// Called when focus, distance, yaw, or pitch is changed
	void m_Precalculate();

	// Mode
	bool m_inputEnabled = true;
	Mode m_mode = Mode::None;
	aeFloat3 m_refocusPos = aeFloat3( 0.0f );
	bool m_refocus = false;

	// Positioning
	aeFloat3 m_focusPos = aeFloat3( 0.0f );
	float m_dist = 5.0f;

	// Rotation
	float m_yaw = 0.77f;
	float m_pitch = 0.5f;

	// Pre-calculated values for getters
	aeFloat3 m_offset;
	aeFloat3 m_forward;
	aeFloat3 m_right;
	aeFloat3 m_up;
};

#endif
//------------------------------------------------------------------------------
// aeAlloc.h
// Utilities for allocating objects. Provides functionality to track current and
// past allocations.
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
// @NOTE: These functions currently do not handle misbehaving shell extensions
// well on Windows. In particular p4bridge had to be disabled on my system due to
// a crash upon hovering over folders. If you run into an issue that you are
// unable to resolve while using these functions, try setting 'useLegacy' to true.
//------------------------------------------------------------------------------
#ifndef AEFILEDIALOG_H
#define AEFILEDIALOG_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------
class aeWindow;
namespace AE_NAMESPACE {
#if !_AE_APPLE_ // No std::path support

//------------------------------------------------------------------------------
// FileFilter for OpenFileParams/SaveFileParams
//------------------------------------------------------------------------------
struct FileFilter
{
  FileFilter() = default;
  FileFilter( const char* desc, const char* ext ) : description( desc ) { extensions[ 0 ] = ext; }
  FileFilter( const char* desc, const char** ext, uint32_t extensionCount );
  const char* description = ""; // "JPEG"
  // Only alphanumeric extension strings are supported (with the exception of "*")
  const char* extensions[ 8 ] = { 0 }; // { "JPG", "JPEG", "JPE" }
};

//------------------------------------------------------------------------------
// OpenFile
//------------------------------------------------------------------------------
struct OpenFileParams
{
  const char* windowTitle = "Open";
  Array< FileFilter > filters; // Leave empty for { ae::FileFilter( "All Files", "*" ) }

  aeWindow* window = nullptr; // Recommended. Setting this will create a modal 'Open' dialog.
  const char* defaultPath = "";
  // @TODO: allowMultiselect
  bool useLegacy = false;
};
Array< std::string > OpenFile( const OpenFileParams& params ); // See note at top of header

//------------------------------------------------------------------------------
// SaveFile
//------------------------------------------------------------------------------
struct SaveFileParams
{
  const char* windowTitle = "Save As";
  Array< FileFilter > filters; // Leave empty for { ae::FileFilter( "All Files", "*" ) }

  aeWindow* window = nullptr; // Recommended. Setting this will create a modal 'Save As' dialog.
  const char* defaultPath = "";
  bool confirmOverwrite = true;
  bool useLegacy = false;
};
std::string SaveFile( const SaveFileParams& params ); // See note at top of header

#endif

} // ae namespace end

#endif
//------------------------------------------------------------------------------
// Meta.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEMETA_H
#define AEMETA_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------
#include <map>

//------------------------------------------------------------------------------
// Meta constants
//------------------------------------------------------------------------------
class aeObject;
typedef uint32_t aeMetaTypeId;
const aeMetaTypeId kAeInvalidMetaTypeId = 0;
const uint32_t kMaxMetaTypes = 64;
const uint32_t kMaxMetaProps = 8;
const uint32_t kMaxMetaVars = 16;

//------------------------------------------------------------------------------
// Internal function wrappers
//------------------------------------------------------------------------------
template< typename T >
static aeObject* PlacementNewInternal( aeObject* d ) { return new( d ) T(); }

//------------------------------------------------------------------------------
// External macros to force module linking
//------------------------------------------------------------------------------
#define AE_META_CLASS_FORCE_LINK(x) \
extern int force_link_##x; \
struct Some_##x { Some_##x() { force_link_##x = 1; } }; \
Some_##x some_##x;

//------------------------------------------------------------------------------
// Internal meta forward declarations
//------------------------------------------------------------------------------
static aeMetaTypeId aeMetaGetObjectTypeId( const aeObject* obj );

//------------------------------------------------------------------------------
// External meta types
//------------------------------------------------------------------------------
class aeMeta
{
public:
  class Type;
  
  class Enum
  {
  public:
    const char* GetName() const { return m_name.c_str(); }
    
    uint32_t TypeSize() const { return m_size; }
    bool TypeIsSigned() const { return m_isSigned; }
    
    template < typename T >
    std::string GetNameByValue( T value ) const { return m_enumValueToName.Get( (int32_t)value, "" ); }
      
    template < typename T >
    bool GetValueFromString( const char* str, T* valueOut ) const
    {
      int32_t value = 0;
      if ( m_enumNameToValue.TryGet( str, &value ) ) // Set object var with named enum value
      {
        *valueOut = (T)value;
        return true;
      }
      else if ( isdigit( str[ 0 ] ) || str[ 0 ] == '-' ) // Set object var with a numerical enum value
      {
        value = atoi( str );
        if ( HasValue( value ) )
        {
          *valueOut = (T)value;
          return true;
        }
      }
      
      return false;
    }
    
    template < typename T >
    bool HasValue( T value ) const { return m_enumValueToName.TryGet( value ); }
    
    int32_t GetValueByIndex( int32_t index ) const { return m_enumValueToName.GetKey( index ); }
    std::string GetNameByIndex( int32_t index ) const { return m_enumValueToName.GetValue( index ); }
    uint32_t Length() const { return m_enumValueToName.Length(); }
    
    template < typename T >
    static std::string GetNameFromValue( T value )
    {
      const Enum* enumType = GetEnum< T >();
      AE_ASSERT( enumType );
      return enumType->m_enumValueToName.Get( (int32_t)value, "" );
    }
    
    template < typename T >
    static T GetValueFromString( const char* str, T defaultValue )
    {
      const Enum* enumType = GetEnum< T >();
      AE_ASSERT_MSG( enumType, "Value '#' has no Enum #", str, typeid(T).name() ); // TODO: Pretty print
      enumType->GetValueFromString( str, &defaultValue );
      return defaultValue;
    }
  
  private:
    aeStr32 m_name;
    uint32_t m_size;
    bool m_isSigned;
    ae::Map< int32_t, std::string > m_enumValueToName;
    ae::Map< std::string, int32_t > m_enumNameToValue;
    
  public: // Internal
    Enum( const char* name, uint32_t size, bool isSigned ) :
      m_name( name ),
      m_size( size ),
      m_isSigned( isSigned )
    {}
    
    void m_AddValue( const char* name, int32_t value )
    {
      m_enumValueToName.Set( value, name );
      m_enumNameToValue.Set( name, value );
    }
    
    static Enum* s_Get( const char* enumName, bool create, uint32_t size, bool isSigned )
    {
      static ae::Map< std::string, Enum* > enums;
      if ( create )
      {
        AE_ASSERT( !enums.TryGet( enumName ) );
        return enums.Set( enumName, aeAlloc::Allocate< Enum >( enumName, size, isSigned ) );
      }
      else
      {
        return enums.Get( enumName );
      }
    }
  };
  
  class Var
  {
  public:
    enum Type
    {
      String,
      UInt8,
      UInt16,
      UInt32,
      Int8,
      Int16,
      Int32,
      Bool,
      Float,
      // V2f,
      // V2i,
      Float4x4,
      Enum,
      Ref
    };

    const char* GetName() const { return m_name.c_str(); }
    Var::Type GetType() const { return m_type; }
    const char* GetTypeName() const { return m_typeName.c_str(); }
    uint32_t GetOffset() const { return m_offset; }
    uint32_t GetSize() const { return m_size; }
    
    // @TODO: Replace return type with an dynamic aeStr
    std::string GetObjectValueAsString( const aeObject* obj, std::function< std::string( const aeObject* ) > getStringFromObjectPointer = nullptr ) const
    {
      if ( !obj )
      {
        return "";
      }
      
      // @TODO: Add debug safety check to make sure 'this' Var belongs to 'obj' aeMeta::Type
      
      const void* varData = reinterpret_cast< const uint8_t* >( obj ) + m_offset;
      
      switch ( m_type )
      {
        case Var::String:
          switch ( m_size )
          {
            case 16:
              return reinterpret_cast< const aeStr16* >( varData )->c_str();
            case 32:
              return reinterpret_cast< const aeStr32* >( varData )->c_str();
            case 64:
              return reinterpret_cast< const aeStr64* >( varData )->c_str();
            case 128:
              return reinterpret_cast< const aeStr128* >( varData )->c_str();
            case 256:
              return reinterpret_cast< const aeStr256* >( varData )->c_str();
            case 512:
              return reinterpret_cast< const aeStr512* >( varData )->c_str();
            default:
              AE_FAIL_MSG( "Invalid string size '#'", m_size );
              return "";
          }
        case Var::UInt8:
          return aeStr32::Format( "#", *reinterpret_cast< const uint8_t* >( varData ) ).c_str();
        case Var::UInt16:
          return aeStr32::Format( "#", *reinterpret_cast< const uint16_t* >( varData ) ).c_str();
        case Var::UInt32:
          return aeStr32::Format( "#", *reinterpret_cast< const uint32_t* >( varData ) ).c_str();
        case Var::Int8:
          return aeStr32::Format( "#", *reinterpret_cast< const int8_t* >( varData ) ).c_str();
        case Var::Int16:
          return aeStr32::Format( "#", *reinterpret_cast< const int16_t* >( varData ) ).c_str();
        case Var::Int32:
          return aeStr32::Format( "#", *reinterpret_cast< const int32_t* >( varData ) ).c_str();
        case Var::Bool:
          return aeStr32::Format( "#", *reinterpret_cast< const bool* >( varData ) ).c_str();
        case Var::Float:
          return aeStr32::Format( "#", *reinterpret_cast< const float* >( varData ) ).c_str();
        case Var::Float4x4:
          return aeStr256::Format( "#", *reinterpret_cast< const aeFloat4x4* >( varData ) ).c_str();
        case Var::Enum:
        {
          const class Enum* enumType = GetEnum();
          int32_t value = 0;
          switch ( enumType->TypeSize() )
          {
            case 1: value = *reinterpret_cast< const int8_t* >( varData ); break;
            case 2: value = *reinterpret_cast< const int16_t* >( varData ); break;
            case 4: value = *reinterpret_cast< const int32_t* >( varData ); break;
            case 8: value = *reinterpret_cast< const int64_t* >( varData ); break;
            default: AE_FAIL();
          }
          return enumType->GetNameByValue( value );
        }
        case Var::Ref:
        {
          AE_ASSERT_MSG( getStringFromObjectPointer, "Must provide mapping function for reference types when calling GetObjectValueAsString" );
          class aeObject* const * obj = reinterpret_cast< class aeObject* const * >( varData );
          return getStringFromObjectPointer( *obj ).c_str();
        }
      }
      
      return "";
    }
    
    bool SetObjectValueFromString( aeObject* obj, const char* value, std::function< bool( const char*, aeObject** ) > getObjectPointerFromString = nullptr ) const
    {
      if ( !obj )
      {
        return false;
      }
      
      // @TODO: Add debug safety check to make sure 'this' Var belongs to 'obj' aeMeta::Type
      
      void* varData = (uint8_t*)obj + m_offset;
      
      switch ( m_type )
      {
        case Var::String:
        {
          switch ( m_size )
          {
            case 16:
            {
              *(aeStr16*)varData = value;
              return true;
            }
            case 32:
            {
              *(aeStr32*)varData = value;
              return true;
            }
            case 64:
            {
              aeStr64* str = (aeStr64*)varData;
              *str = value;
              return true;
            }
            case 128:
            {
              aeStr128* str = (aeStr128*)varData;
              *str = value;
              return true;
            }
            case 256:
            {
              aeStr256* str = (aeStr256*)varData;
              *str = value;
              return true;
            }
            case 512:
            {
              aeStr512* str = (aeStr512*)varData;
              *str = value;
              return true;
            }
            default:
            {
              AE_ASSERT_MSG( false, "Invalid string size '#'", m_size );
              return false;
            }
          }
        }
        case Var::UInt8:
        {
          AE_ASSERT(m_size == sizeof(uint8_t) );
          uint8_t* u8 = (uint8_t*)varData;
          sscanf( value, "%hhu", u8 );
          return true;
        }
        case Var::UInt16:
        {
          AE_ASSERT(m_size == sizeof(uint16_t) );
          uint16_t* u16 = (uint16_t*)varData;
          sscanf( value, "%hu", u16 );
          return true;
        }
        case Var::UInt32:
        {
          AE_ASSERT(m_size == sizeof(uint32_t) );
          uint32_t* u32 = (uint32_t*)varData;
          sscanf( value, "%u", u32 );
          return true;
        }
        case Var::Int8:
        {
          AE_ASSERT(m_size == sizeof(int8_t) );
          int8_t* i8 = (int8_t*)varData;
          sscanf( value, "%hhd", i8 );
          return true;
        }
        case Var::Int16:
        {
          AE_ASSERT(m_size == sizeof(int16_t) );
          int16_t* i16 = (int16_t*)varData;
          sscanf( value, "%hd", i16 );
          return true;
        }
        case Var::Int32:
        {
          AE_ASSERT(m_size == sizeof(int32_t) );
          int32_t* i32 = (int32_t*)varData;
          sscanf( value, "%d", i32 );
          return true;
        }
        case Var::Bool:
        {
          // @TODO: Clean this up. Should check for both `true` and `false`, and return false if neither match
          const char* trueStr = "true";
          bool b = value[ 0 ];
          if ( b )
          {
            for ( uint32_t i = 0; ( value[ i ] && trueStr[ i ] ); i++ )
            {
              if ( trueStr[ i ] != tolower( value[ i ] ) )
              {
                b = false;
              }
            }
          }
          *(bool*)varData = b;
          return true;
        }
        case Var::Float:
        {
          AE_ASSERT( m_size == sizeof(float) );
          float* f = (float*)varData;
          sscanf( value, "%f", f );
          return true;
        }
          // case Var::V2f:
          // {
          //   AE_ASSERT( var->m_size == sizeof(v2f) );
          //   v2f* v = (v2f*)varData;
          //   sscanf( value, "%f %f", &(v->X), &(v->Y) );
          //   return true;
          // }
          // case Var::V2i:
          // {
          //   AE_ASSERT( var->m_size == sizeof(v2i) );
          //   v2i* v = (v2i*)varData;
          //   sscanf( value, "%d %d", &(v->X), &(v->Y) );
          //   return true;
          // }
        case Var::Float4x4:
        {
          AE_ASSERT( m_size == sizeof(aeFloat4x4) );
          aeFloat4x4* v = (aeFloat4x4*)varData;
          // @TODO: Should match GetObjectValueAsString() which uses aeStr::Format
          sscanf( value, "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f",
                 v->data, v->data + 1, v->data + 2, v->data + 3,
                 v->data + 4, v->data + 5, v->data + 6, v->data + 7,
                 v->data + 8, v->data + 9, v->data + 10, v->data + 11,
                 v->data + 12, v->data + 13, v->data + 14, v->data + 15 );
          return true;
        }
        case Var::Enum:
        {
          if ( !value[ 0 ] )
          {
            return false;
          }
          
          const class Enum* enumType = GetEnum();
          
          if ( enumType->TypeIsSigned() )
          {
            switch ( enumType->TypeSize() )
            {
            case 1:
              return enumType->GetValueFromString( value, reinterpret_cast< int8_t* >( varData ) );
            case 2:
              return enumType->GetValueFromString( value, reinterpret_cast< int16_t* >( varData ) );
            case 4:
              return enumType->GetValueFromString( value, reinterpret_cast< int32_t* >( varData ) );
            case 8:
              return enumType->GetValueFromString( value, reinterpret_cast< int64_t* >( varData ) );
            default:
              AE_FAIL();
              return false;
            }
          }
          else
          {
            switch ( enumType->TypeSize() )
            {
            case 1:
              return enumType->GetValueFromString( value, reinterpret_cast< uint8_t* >( varData ) );
            case 2:
              return enumType->GetValueFromString( value, reinterpret_cast< uint16_t* >( varData ) );
            case 4:
              return enumType->GetValueFromString( value, reinterpret_cast< uint32_t* >( varData ) );
            case 8:
              return enumType->GetValueFromString( value, reinterpret_cast< uint64_t* >( varData ) );
            default:
              AE_FAIL();
              return false;
            }
          }
          return false;
        }
        case Var::Ref:
        {
          AE_ASSERT( m_refType );
          AE_ASSERT_MSG( getObjectPointerFromString, "Must provide mapping function for reference types when calling SetObjectValueFromString" );
          class aeObject* obj = nullptr;
          if ( getObjectPointerFromString( value, &obj ) )
          {
            if ( obj )
            {
              const aeMeta::Type* objType = aeMeta::GetTypeFromObject( obj );
              AE_ASSERT( objType );
              if ( !objType->IsType( m_refType ) )
              {
                return false;
              }
            }
            
            class aeObject** varPtr = reinterpret_cast< class aeObject** >( varData );
            *varPtr = obj;
            return true;
          }
          return false;
        }
      }
      
      return false;
    }
    
    template < typename T >
    bool SetObjectValue( aeObject* obj, const T& value ) const
    {
      if ( !obj )
      {
        return false;
      }
      
      // @TODO: Add debug safety check to make sure 'this' Var belongs to 'obj' aeMeta::Type
      
      Var::Type typeCheck = aeMeta::VarType< T >::GetType();
      AE_ASSERT( typeCheck == m_type );
      AE_ASSERT( m_size == sizeof( T ) );
      
      T* varData = reinterpret_cast< T* >( (uint8_t*)obj + m_offset );
      *varData = value;
      
      return true;
    }
    
    // Enum
    const class Enum* GetEnum() const
    {
      if ( !m_enum )
      {
        if ( m_type != Var::Enum )
        {
          return nullptr;
        }
        m_enum = aeMeta::GetEnum( m_typeName.c_str() );
      }
      return m_enum;
    }

    // Members
    aeStr32 m_name;
    Var::Type m_type;
    aeStr32 m_typeName;
    uint32_t m_offset;
    uint32_t m_size;
    const aeMeta::Type* m_refType;
    mutable const class Enum* m_enum = nullptr;
  };
  
  template < typename T >
  struct VarType
  {
    static Var::Type GetType();
    static const char* GetName();
  };

  //------------------------------------------------------------------------------
  // External MetaType class
  //------------------------------------------------------------------------------
  class Type
  {
  public:
    Type() { memset( this, 0, sizeof( *this ) ); }
    
    template < typename T = aeObject >
    T* New( void* obj ) const
    {
      AE_ASSERT( obj );
      AE_ASSERT_MSG( !m_isAbstract, "Placement new not available for abstract type: #", m_name.c_str() );
      AE_ASSERT_MSG( m_isDefaultConstructible, "Placement new not available for type without default constructor: #", m_name.c_str() );
      AE_ASSERT( m_placementNew );
      AE_ASSERT( IsType< T >() );
      AE_ASSERT( (uint64_t)obj % GetAlignment() == 0 );
      
      return (T*)m_placementNew( (T*)obj );
    }

    aeMetaTypeId GetId() const { return m_id; }
    
    bool HasProp( const char* prop ) const
    {
      auto* result = std::find( m_props, m_props + m_propCount, prop );
      return result < ( m_props + m_propCount );
    }
    
    uint32_t GetVarCount() const { return m_varCount; }
    const Var* GetVarByIndex( uint32_t i ) const { return &m_vars[ i ]; }
    const Var* GetVarByName( const char* name ) const
    {
      auto* result = std::find_if( m_vars, m_vars + m_varCount, [name]( const auto& v )
      {
        return v.m_name == name;
      });
      if ( result < ( m_vars + m_varCount ) )
      {
        return result;
      }
      return nullptr;
    }

    uint32_t GetSize() const { return m_size; }
    uint32_t GetAlignment() const { return m_align; }
    const char* GetName() const { return m_name.c_str(); }
    bool HasNew() const { return m_placementNew; }
    bool IsAbstract() const { return m_isAbstract; }
    bool IsPolymorphic() const { return m_isPolymorphic; }
    bool IsDefaultConstructible() const { return m_isDefaultConstructible; }

    const char* GetBaseTypeName() const { return m_parent.c_str(); }
    const Type* GetBaseType() const { return GetTypeByName( m_parent.c_str() ); }

    bool IsType( const Type* otherType ) const
    {
      AE_ASSERT( otherType );
      for ( const aeMeta::Type* baseType = this; baseType; baseType = baseType->GetBaseType() )
      {
        if ( baseType == otherType )
        {
          return true;
        }
      }
      return false;
    }

    template < typename T >
    bool IsType() const
    {
      const Type* type = GetType< T >();
      AE_ASSERT( type );
      return IsType( type );
    }
    
    //------------------------------------------------------------------------------
    // Internal meta type initialization functions
    //------------------------------------------------------------------------------
    template < typename T >
    typename std::enable_if< !std::is_abstract< T >::value && std::is_default_constructible< T >::value, void >::type
    Init( const char* name, uint32_t index )
    {
      m_placementNew = &( PlacementNewInternal< T > );
      m_name = name;
      m_id = aeHash().HashString( name ).Get();
      m_size = sizeof( T );
      m_align = alignof( T );
      m_parent = T::GetBaseTypeName();
      m_isAbstract = false;
      m_isPolymorphic = std::is_polymorphic< T >::value;
      m_isDefaultConstructible = true;
    }
    template < typename T >
    typename std::enable_if< std::is_abstract< T >::value || !std::is_default_constructible< T >::value, void >::type
    Init( const char* name, uint32_t index )
    {
      m_placementNew = nullptr;
      m_name = name;
      m_id = aeHash().HashString( name ).Get();
      m_size = sizeof( T );
      m_align = 0;
      m_parent = T::GetBaseTypeName();
      m_isAbstract = std::is_abstract< T >::value;
      m_isPolymorphic = std::is_polymorphic< T >::value;
      m_isDefaultConstructible = std::is_default_constructible< T >::value;
    }
    
    void AddProp( const char* prop )
    {
      AE_ASSERT( m_propCount < kMaxMetaProps );
      m_props[ m_propCount++ ] = prop;
      std::sort( &m_props[ 0 ], &m_props[ m_propCount ], []( const auto& a, const auto& b )
      {
        return a < b;
      });
    }

    void AddVar( const Var& var )
    {
      AE_ASSERT( m_varCount < kMaxMetaVars );
      m_vars[ m_varCount++ ] = var;
      std::sort( &m_vars[ 0 ], &m_vars[ m_varCount ], []( const auto& a, const auto& b )
      {
        return a.GetOffset() < b.GetOffset();
      });
    }

    //------------------------------------------------------------------------------
    // Internal meta type state
    //------------------------------------------------------------------------------
  private:
    friend class aeMeta;
    aeObject* ( *m_placementNew )( aeObject* );
    aeStr32 m_name;
    aeMetaTypeId m_id;
    uint32_t m_size;
    uint32_t m_align;
    aeStr32 m_props[ kMaxMetaProps ];
    uint32_t m_propCount;
    Var m_vars[ kMaxMetaVars ];
    uint32_t m_varCount;
    aeStr32 m_parent;
    bool m_isAbstract;
    bool m_isPolymorphic;
    bool m_isDefaultConstructible;
  };

  //------------------------------------------------------------------------------
  // External meta functions
  //------------------------------------------------------------------------------
  static uint32_t GetTypeCount() { return (uint32_t)m_GetTypes().size(); }
  static const Type* GetTypeByIndex( uint32_t i )
  {
    return m_GetTypes()[ i ];
  }

  static const Type* GetTypeById( aeMetaTypeId id )
  {
    return m_GetTypeIdMap()[ id ];
  }

  static const Type* GetTypeByName( const char* typeName )
  {
    auto it = m_GetTypeNameMap().find( typeName );
    if ( it != m_GetTypeNameMap().end() ) { return it->second; }
    else { return nullptr; }
  }

  static const Type* GetTypeFromObject( const aeObject* obj )
  {
    if ( !obj )
    {
      return nullptr;
    }
    
    aeMetaTypeId id = aeMetaGetObjectTypeId( obj );
    auto it = m_GetTypeIdMap().find( id );
    if ( it != m_GetTypeIdMap().end() )
    {
      return it->second;
    }
    else
    {
      AE_ASSERT_MSG( false, "No meta info for object '#' type id: #", obj, (uint32_t)id );
      return nullptr;
    }
  }

  static const Type* GetTypeFromObject( const aeObject& obj )
  {
    return GetTypeFromObject( &obj );
  }

  template < typename T >
  static const Type* GetType()
  {
    const char* typeName = aeGetTypeName< T >();
    auto it = m_GetTypeNameMap().find( typeName );
    if ( it != m_GetTypeNameMap().end() )
    {
      return it->second;
    }
    else
    {
      AE_ASSERT_MSG( false, "No meta info for type name: #", typeName );
      return nullptr;
    }
  }
  
  static const Enum* GetEnum( const char* enumName )
  {
    return Enum::s_Get( enumName, false, 0 , false );
  }
  
  //------------------------------------------------------------------------------
  // External meta initialization helpers
  //------------------------------------------------------------------------------
  template < typename T >
  struct TypeName
  {
    static const char* Get();
  };

  //------------------------------------------------------------------------------
  // Internal meta initialization functions
  //------------------------------------------------------------------------------
  template< typename T >
  static void DefineType( Type* type, uint32_t index );

  template < typename T >
  struct TypeCreator
  {
    TypeCreator( const char *typeName )
    {
      static Type type;
      // aeMetaTypeId id = m_GetNextTypeId();
      DefineType< T >( &type, 0 );
      m_GetTypeNameMap()[ typeName ] = &type;
      m_GetTypeIdMap()[ type.GetId() ] = &type; // @TODO: Should check for hash collision
      m_GetTypes().push_back( &type );
    }
  };

  template< typename C, uint32_t N >
  static void DefineVar( Var* var );

  template< typename C, typename V, uint32_t Offset >
  struct VarCreator
  {
    VarCreator( const char* typeName, const char* varName )
    {
      aeMeta::Type* type = m_GetTypeNameMap().find( typeName )->second;
      
      Var var;
      var.m_name = varName;
      var.m_type = aeMeta::VarType< V >::GetType();
      var.m_typeName = aeMeta::VarType< V >::GetName();
      var.m_refType = aeMeta::VarType< V >::GetRefType();
#if !_AE_WINDOWS_
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Winvalid-offsetof"
#endif
      var.m_offset = Offset; // @TODO: Verify var is not member of base class
#if !_AE_WINDOWS_
    #pragma clang diagnostic pop
#endif
      var.m_size = sizeof(V);

      type->AddVar( var );
    }
  };
  
  template< typename C >
  struct PropCreator
  {
    PropCreator( const char* typeName, const char* propName )
    {
      aeMeta::Type* type = m_GetTypeNameMap().find( typeName )->second;
      type->AddProp( propName );
    }
  };
  
  // @NOTE: Non-specialized GetEnum() has no implementation so templated GetEnum() calls (defined
  // with AE_ENUM, AE_META_ENUM, and AE_META_ENUM_PREFIX) will call the specialized function.
  template < typename T >
  static const Enum* GetEnum();
  
  template < typename E, typename T = typename std::underlying_type< E >::type >
  struct EnumCreator
  {
    EnumCreator( const char* typeName, std::string strMap )
    {
      class aeMeta::Enum* enumType = aeMeta::Enum::s_Get( typeName, true, sizeof( T ), std::is_signed< T >::value );
      
      strMap.erase( std::remove( strMap.begin(), strMap.end(), ' ' ), strMap.end() );
      strMap.erase( std::remove( strMap.begin(), strMap.end(), '(' ), strMap.end() );
      std::vector< std::string > enumTokens( m_SplitString( strMap, ',' ) );

      T currentValue = 0;
      for ( auto iter = enumTokens.begin(); iter != enumTokens.end(); ++iter )
      {
        std::string enumName;
        if ( iter->find( '=' ) == std::string::npos )
        {
          enumName = *iter;
        }
        else
        {
          std::vector<std::string> enumNameValue( m_SplitString( *iter, '=' ) );
          enumName = enumNameValue[ 0 ];
          if ( std::is_unsigned< T >::value )
          {
            currentValue = static_cast< T >( std::stoull( enumNameValue[ 1 ], 0, 0 ) );
          }
          else
          {
            currentValue = static_cast< T >( std::stoll( enumNameValue[ 1 ], 0, 0 ) );
          }
        }
        
        enumType->m_AddValue( enumName.c_str(), currentValue );
        currentValue++;
      }
    }
    
  private:
    static std::vector< std::string > m_SplitString( std::string str, char separator )
    {
      std::vector< std::string > result;

      std::string item;
      std::stringstream stringStream( str );
      while ( std::getline( stringStream, item, separator ) )
      {
        result.push_back( item );
      }

      return result;
    }
  };
  
  template < typename T >
  class EnumCreator2
  {
  public:
    EnumCreator2( const char* typeName )
    {
      aeMeta::Enum::s_Get( typeName, true, sizeof( T ), std::is_signed< T >::value );
    }
    
    EnumCreator2( const char* valueName, T value )
    {
      const char* prefix = aeMeta::VarType< T >::GetPrefix();
      uint32_t prefixLen = strlen( prefix );
      AE_ASSERT( prefixLen < strlen( valueName ) );
      AE_ASSERT( memcmp( prefix, valueName, prefixLen ) == 0 );
      
      aeMeta::Enum* enumType = const_cast< aeMeta::Enum* >( aeMeta::GetEnum< T >() );
      AE_ASSERT_MSG( enumType, "Could not register enum value '#'. No registered Enum.", valueName );
      enumType->m_AddValue( valueName + prefixLen, (int32_t)value );
    }
  };

  //------------------------------------------------------------------------------
  // Internal meta state
  //------------------------------------------------------------------------------
private:
  // @TODO: Add actual meta type index
  // static aeMetaTypeIndex m_GetNextTypeIndex()
  // {
  //   static aeMetaTypeIndex s_nextTypeId = 0;
  //   s_nextTypeId++;
  //   return s_nextTypeId;
  // }

  static std::map< aeStr32, Type* >& m_GetTypeNameMap()
  {
    static std::map< aeStr32, Type* > s_map;
    return s_map;
  }

  static std::map< aeMetaTypeId, Type* >& m_GetTypeIdMap()
  {
    static std::map< aeMetaTypeId, Type* > s_map;
    return s_map;
  }

  static std::vector< Type* >& m_GetTypes()
  {
    static std::vector< Type* > s_vec;
    return s_vec;
  }
};

//------------------------------------------------------------------------------
// Internal meta var registration
//------------------------------------------------------------------------------
#define DefineMetaVarType( t, e ) \
template <> \
struct aeMeta::VarType< t > { \
static aeMeta::Var::Type GetType() { return aeMeta::Var::e; } \
static const char* GetName() { return #t; } \
static const aeMeta::Type* GetRefType() { return nullptr; } \
};

DefineMetaVarType( uint8_t, UInt8 );
DefineMetaVarType( uint16_t, UInt16 );
DefineMetaVarType( uint32_t, UInt32 );
DefineMetaVarType( int8_t, Int8 );
DefineMetaVarType( int16_t, Int16 );
DefineMetaVarType( int32_t, Int32 );
DefineMetaVarType( bool, Bool );
DefineMetaVarType( float, Float );
// DefineMetaVarType( v2f, V2f );
// DefineMetaVarType( v2i, V2i );
DefineMetaVarType( aeFloat4x4, Float4x4 );

template < uint32_t N >
struct aeMeta::VarType< aeStr<N> >
{
  static aeMeta::Var::Type GetType() { return aeMeta::Var::String; }
  static const char* GetName() { return "String"; }
  static const aeMeta::Type* GetRefType() { return nullptr; }
};

template < typename T >
struct aeMeta::VarType< T* >
{
  static aeMeta::Var::Type GetType()
  {
    static_assert( std::is_base_of< aeObject, T >::value, "AE_META_VAR refs must have base type aeObject" );
    return aeMeta::Var::Ref;
  }
  static const char* GetName() { return "Ref"; }
  static const aeMeta::Type* GetRefType() { return aeMeta::GetType< T >(); }
};

//------------------------------------------------------------------------------
// External meta class registerer
//------------------------------------------------------------------------------
#define AE_META_CLASS( x ) \
int force_link_##x = 0; \
template <> const char* aeMeta::TypeName< x >::Get() { return #x; } \
template <> void aeMeta::DefineType< x >( Type *type, uint32_t index ) { type->Init< x >( #x, index ); } \
static aeMeta::TypeCreator< x > ae_type_creator_##x( #x );

//------------------------------------------------------------------------------
// External meta var registerer
//------------------------------------------------------------------------------
#define AE_META_VAR( c, v ) \
static aeMeta::VarCreator< c, decltype(c::v), offsetof( c, v ) > ae_var_creator_##c##_##v( #c, #v );
//------------------------------------------------------------------------------
// External meta property registerer
//------------------------------------------------------------------------------
#define AE_META_PROPERTY( c, p ) \
static aeMeta::PropCreator< c > ae_prop_creator_##c##_##p( #c, #p );

//------------------------------------------------------------------------------
// External enum definer and registerer
//------------------------------------------------------------------------------
// Define a new enum (must register with AE_ENUM_REGISTER)
#define AE_ENUM( E, T, ... ) \
  enum class E : T { \
    __VA_ARGS__ \
  }; \
  template <> \
  struct aeMeta::VarType< E > { \
    static aeMeta::Var::Type GetType() { return aeMeta::Var::Enum; } \
    static const char* GetName() { return #E; } \
    static const aeMeta::Type* GetRefType() { return nullptr; } \
  }; \
  struct AE_ENUM_##E { AE_ENUM_##E( const char* name = #E, const char* def = #__VA_ARGS__ ); };\
  static std::ostream &operator << ( std::ostream &os, E e ) { \
    os << aeMeta::GetEnum( #E )->GetNameByValue( (int32_t)e ); \
    return os; \
  }

// Register an enum defined with AE_ENUM
#define AE_ENUM_REGISTER( E ) \
  AE_ENUM_##E::AE_ENUM_##E( const char* name, const char* def ) { aeMeta::EnumCreator< E > ec( name, def ); } \
  AE_ENUM_##E ae_enum_creator_##E; \
  template <> const aeMeta::Enum* aeMeta::GetEnum< E >() { static const aeMeta::Enum* e = GetEnum( #E ); return e; }

//------------------------------------------------------------------------------
// External c-style enum registerer
//------------------------------------------------------------------------------
// Register an already defined c-style enum type
#define AE_META_ENUM( E ) \
  template <> \
  struct aeMeta::VarType< E > { \
    static aeMeta::Var::Type GetType() { return aeMeta::Var::Enum; } \
    static const char* GetName() { return #E; } \
    static const aeMeta::Type* GetRefType() { return nullptr; } \
    static const char* GetPrefix() { return ""; } \
  }; \
  aeMeta::EnumCreator2< E > ae_enum_creator_##E( #E ); \
  template <> const aeMeta::Enum* aeMeta::GetEnum< E >() { static const aeMeta::Enum* e = GetEnum( #E ); return e; }

// Register an already defined c-style enum type where each value has a prefix
#define AE_META_ENUM_PREFIX( E, PREFIX ) \
  template <> \
  struct aeMeta::VarType< E > { \
    static aeMeta::Var::Type GetType() { return aeMeta::Var::Enum; } \
    static const char* GetName() { return #E; } \
    static const aeMeta::Type* GetRefType() { return nullptr; } \
    static const char* GetPrefix() { return #PREFIX; } \
  }; \
  aeMeta::EnumCreator2< E > ae_enum_creator_##E( #E ); \
  template <> const aeMeta::Enum* aeMeta::GetEnum< E >() { static const aeMeta::Enum* e = GetEnum( #E ); return e; }

// Register c-style enum value
#define AE_META_ENUM_VALUE( E, V ) \
  aeMeta::EnumCreator2< E > ae_enum_creator_##E##_##V( #V, V );

// Register c-style enum value with a manually specified name
#define AE_META_ENUM_VALUE_NAME( E, V, N ) \
aeMeta::EnumCreator2< E > ae_enum_creator_##E##_##V( #N, V );

//------------------------------------------------------------------------------
// External enum class registerer
//------------------------------------------------------------------------------
// Register an already defined enum class type
#define AE_META_ENUM_CLASS( E ) \
  template <> \
  struct aeMeta::VarType< E > { \
    static aeMeta::Var::Type GetType() { return aeMeta::Var::Enum; } \
    static const char* GetName() { return #E; } \
    static const aeMeta::Type* GetRefType() { return nullptr; } \
    static const char* GetPrefix() { return ""; } \
  }; \
  namespace aeEnums::_##E { aeMeta::EnumCreator2< E > ae_enum_creator( #E ); } \
  template <> const aeMeta::Enum* aeMeta::GetEnum< E >() { static const aeMeta::Enum* e = GetEnum( #E ); return e; }
  // @NOTE: Nested namespace declaration requires C++17

// Register enum class value
#define AE_META_ENUM_CLASS_VALUE( E, V ) \
  namespace aeEnums::_##E { aeMeta::EnumCreator2< E > ae_enum_creator_##V( #V, E::V ); }

//------------------------------------------------------------------------------
// External base meta object
//------------------------------------------------------------------------------
class aeObject
{
public:
  virtual ~aeObject() {}
  static const char* GetBaseTypeName() { return ""; }
  static const aeMeta::Type* GetBaseType() { return nullptr; }
  aeMetaTypeId GetTypeId() const { return _metaTypeId; }

  aeMetaTypeId _metaTypeId;
  aeStr32 _typeName;
};

//------------------------------------------------------------------------------
// External inheritor meta object
//------------------------------------------------------------------------------
template < typename Parent, typename Child >
class aeInheritor : public Parent
{
public:
  aeInheritor()
  {
    const aeMeta::Type* t = aeMeta::GetTypeByName( aeMeta::TypeName< Child >::Get() );
    AE_ASSERT_MSG( t, "No inheritor type" );
    aeObject::_metaTypeId = t->GetId();
    aeObject::_typeName = aeMeta::TypeName< Child >::Get();
  }

  typedef Parent aeBaseType;

  static const char* GetBaseTypeName() { return aeMeta::TypeName< Parent >::Get(); }
  static const aeMeta::Type* GetBaseType() { return aeMeta::GetType( aeMeta::TypeName< Parent >::Get() ); }
};

//------------------------------------------------------------------------------
// aeCast
//------------------------------------------------------------------------------
template< typename T, typename C >
const T* aeCast( const C* obj )
{
  // Cast down to base
  static_assert( std::is_base_of< C, T >::value || std::is_base_of< T, C >::value, "Unrelated types" );
  return dynamic_cast< const T* >( obj );
}

template< typename T, typename C >
T* aeCast( C* obj )
{
  // Cast down to base
  static_assert( std::is_base_of< C, T >::value || std::is_base_of< T, C >::value, "Unrelated types" );
  return dynamic_cast< T* >( obj );
}

//------------------------------------------------------------------------------
// Internal aeObject functions
//------------------------------------------------------------------------------
static aeMetaTypeId aeMetaGetObjectTypeId( const aeObject* obj )
{
  return obj->_metaTypeId;
}

#endif
//------------------------------------------------------------------------------
// aeRef.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEREF_H
#define AEREF_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeRef interface helper macro
//------------------------------------------------------------------------------
#define AE_REFABLE( _C )\
aeId< _C > GetId() const { return m_refable.GetId(); }\
static _C* GetById( aeId< _C > id ) { return aeRefable< _C >::GetById( id ); }\
aeRefable< _C > m_refable = this;

//------------------------------------------------------------------------------
// aeId class
//------------------------------------------------------------------------------
template < typename T >
class aeId
{
public:
  static aeId CreateNew() { static uint32_t s_current = 0; s_current++; return aeId( s_current ); }

  aeId() { m_id = 0; }

  template< typename U, typename std::enable_if< std::is_base_of< T, U >{}, int>::type = 0 > // Allow automatic downcast to U
  aeId( const aeId< U >& other ) { m_id = other.m_id; }

  template< typename U, typename std::enable_if< std::is_base_of< U, T >{}, int>::type = 0 > // Allow explicit upcast to U
  explicit aeId( const aeId< U >& other ) { m_id = other.m_id; }

  explicit operator bool() const { return m_id != 0; }
  bool operator == ( aeId other ) const { return m_id == other.m_id; }
  bool operator != ( aeId other ) const { return !operator == ( other ); }

private:
  template < typename T2 >
  friend class aeId;

  template < typename T2 >
  friend std::ostream& operator<<( std::ostream& os, const aeId< T2 >& id );

  explicit aeId( uint32_t id ) { m_id = id; }
  
  uint32_t m_id;
public:
  uint32_t GetInternalId() const { return m_id; }
};

template < typename T >
inline std::ostream& operator<<( std::ostream& os, const aeId< T >& id )
{
  return os << id.m_id;
}

//------------------------------------------------------------------------------
// aeRefable class
//------------------------------------------------------------------------------
template < typename T >
class aeRefable
{
public:
  aeRefable( T* owner ) : m_id( aeId< T >::CreateNew() ) { s_GetMap()->Set( m_id, owner ); }
  ~aeRefable() { s_GetMap()->Remove( m_id ); }

  aeId< T > GetId() const { return m_id; }
  static T* GetById( aeId< T > id ) { return s_GetMap()->Get( id, nullptr ); }

private:
  //aeRefable( const aeRefable& ) = delete; // @HACK: Disabled this to support automatic 'this' assignment with AE_REFABLE
  aeRefable& operator= ( const aeRefable& ) = delete;

  // uint32_t s_sequence = 1; @TODO: Increment a 'dirty' sequence number whenever a T is destroyed so aeRef can keep a pointer to the referenced object and avoid a lookup
  typedef aeMap< aeId< T >, T* > RefMap;
  static RefMap* s_GetMap() { static RefMap s_map; return &s_map; }

  aeId< T > m_id;
};

//------------------------------------------------------------------------------
// aeRef class
//------------------------------------------------------------------------------
template < typename T >
class aeRef
{
public:
  aeRef() = default;
  aeRef( T* obj );
  aeRef( aeId< T > id );
  aeRef( const aeRef& ) = default;

  aeId< T > GetId() const { return m_id; }

  explicit operator bool() const;
  operator const T*() const;
  operator T*();

  const T* operator ->() const;
  const T& operator *() const;
  T* operator ->();
  T& operator *();

  bool Lost() const;

private:
  // Provide m_Get() defaults to allow templated types that don't support T::GetById()
  template < typename U, bool result = std::is_same< decltype( ((U*)nullptr)->GetById( aeId< U >() ) ), U* >::value >
  const U* m_Get( int ) const;
  
  template < typename U, bool result = std::is_same< decltype( ((U*)nullptr)->GetById( aeId< U >() ) ), U* >::value >
  U* m_Get( int );
  
  template < typename U >
  const U* m_Get( ... ) const;
  
  template < typename U >
  U* m_Get( ... );

  aeId< T > m_id;
  // uint32_t m_sequence = 0; @TODO: Keep a pointer to the referenced object and a local copy aeRef< T >::s_sequence so sequential lookups are fast
  // T* m_cached = nullptr;
};

//------------------------------------------------------------------------------
// aeRefPair class
//------------------------------------------------------------------------------
template < typename T, typename S >
class aeRefPair
{
public:
  aeRefPair( T* self );
  ~aeRefPair();
  
  void Pair( aeRefPair< S, T >& other );
  void Clear();
  
  S* Get();
  const S* Get() const;
  
private:
  friend class aeRefPair< S, T >;
  T* m_self;
  aeRefPair< S, T >* m_other;
};

//------------------------------------------------------------------------------
// aeRef member functions
//------------------------------------------------------------------------------
template < typename T >
aeRef< T >::aeRef( T* obj )
{
  // Make sure T::GetById() is implemented for T at compile time only if a ref is ever actually constructed
  auto GetByID_NotImplemented = &T::GetById;

  if ( obj )
  {
    m_id = aeId< T >( obj->GetId() );
    AE_ASSERT( m_id );
  }
  else
  {
    m_id = aeId< T >();
  }
}

template < typename T >
aeRef< T >::aeRef( aeId< T > id )
  : m_id( id )
{}

template < typename T >
aeRef< T >::operator bool() const
{
  return m_Get< T >( 0 ) != nullptr;
}

template < typename T >
aeRef< T >::operator const T*() const
{
  return m_Get< T >( 0 );
}

template < typename T >
aeRef< T >::operator T*()
{
  return m_Get< T >( 0 );
}

template < typename T >
const T* aeRef< T >::operator ->() const
{
  return &(operator *());
}

template < typename T >
T* aeRef< T >::operator ->()
{
  return &(operator *());
}

template < typename T >
const T& aeRef< T >::operator *() const
{
  AE_ASSERT( m_id );
  auto obj = m_Get< T >( 0 );
  AE_ASSERT( obj );
  return *aeCast< T >( obj );
}

template < typename T >
T& aeRef< T >::operator *()
{
  AE_ASSERT( m_id );
  auto obj = m_Get< T >( 0 );
  AE_ASSERT( obj );
  return *aeCast< T >( obj );
}

template < typename T >
bool aeRef< T >::Lost() const
{
  return m_Get< T >( 0 ) == nullptr && m_id != aeId< T >();
}

template < typename T >
template < typename U, bool >
const U* aeRef< T >::m_Get( int ) const
{
  return m_id ? aeCast< T >( T::GetById( m_id ) ) : nullptr;
}

template < typename T >
template < typename U, bool >
U* aeRef< T >::m_Get( int )
{
  return m_id ? aeCast< T >( T::GetById( m_id ) ) : nullptr;
}

template < typename T >
template < typename U >
const U* aeRef< T >::m_Get( ... ) const
{
  return nullptr;
}

template < typename T >
template < typename U >
U* aeRef< T >::m_Get( ... )
{
  return nullptr;
}

//------------------------------------------------------------------------------
// aeRefPair member functions
//------------------------------------------------------------------------------
template < typename T, typename S >
aeRefPair< T, S >::aeRefPair( T* self ) :
  m_self( self ),
  m_other( nullptr )
{
  AE_ASSERT( self );
}

template < typename T, typename S >
aeRefPair< T, S >::~aeRefPair()
{
  Clear();
}

template < typename T, typename S >
void aeRefPair< T, S >::Pair( aeRefPair< S, T >& other )
{
  if ( m_other == &other )
  {
    return;
  }
  
  if ( m_other )
  {
    m_other->Clear();
  }
  other.Clear();
  
  m_other = &other;
  other.m_other = this;
}

template < typename T, typename S >
void aeRefPair< T, S >::Clear()
{
  if ( m_other )
  {
    m_other->m_other = nullptr;
    m_other = nullptr;
  }
}

template < typename T, typename S >
S* aeRefPair< T, S >::Get()
{
  return m_other ? m_other->m_self : nullptr;
}

template < typename T, typename S >
const S* aeRefPair< T, S >::Get() const
{
  return m_other ? m_other->m_self : nullptr;
}

#endif
//------------------------------------------------------------------------------
// aeSignal.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AESIGNAL_H
#define AESIGNAL_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeSignalBase class
//------------------------------------------------------------------------------
class aeSignalBase
{
public:
  aeSignalBase() {}
  virtual ~aeSignalBase() {}

  virtual bool Send() = 0;

public:
  // Internal use
  virtual void* GetObj() = 0;
};

//------------------------------------------------------------------------------
// aeSignalValue class
//------------------------------------------------------------------------------
template < typename V >
class aeSignalValue : public aeSignalBase
{
public:
  aeSignalValue();
  aeSignalValue( const V& val );
  virtual ~aeSignalValue() {}

  virtual bool Send( const V& value ) = 0;

protected:
  bool m_valSet;
  V m_val;

public:
  // Internal use
  bool HasValue();
};

//------------------------------------------------------------------------------
// aeSignal class
//------------------------------------------------------------------------------
template < typename T, typename V = int32_t >
class aeSignal : public aeSignalValue< V >
{
public:
  aeSignal();
  ~aeSignal();
  
  aeSignal( T* obj, void ( T::* fn ) () );
  aeSignal( T* obj, void ( T::* fn ) ( V ) );
  aeSignal( T* obj, void ( T::* fn ) ( V ), const V& value );

  aeSignal( aeRef< T >& ref, void ( T::* fn ) () );
  aeSignal( aeRef< T >& ref, void ( T::* fn ) ( V ) );
  aeSignal( aeRef< T >& ref, void ( T::* fn ) ( V ), const V& value );

  bool Send() override;
  bool Send( const V& value ) override;

private:
  T* m_obj;
  aeRef< T > m_ref;
  
  void ( T::* m_fn )();
  void ( T::* m_fnVal )( V );

  bool m_isCalled;

public:
  // Internal use
  void* GetObj() override;
};

//------------------------------------------------------------------------------
// aeSignalList class
//------------------------------------------------------------------------------
template < typename V = int32_t >
class aeSignalList
{
public:
  ~aeSignalList();

  template < typename T, typename Fn > void Add( T* obj, Fn fn );
  template < typename T, typename Fn > void Add( aeRef< T > ref, Fn fn );

  void Remove( void* obj );
  
  void Send();
  template < typename T > void Send( const T& value );

  uint32_t Length() const;

private:
  aeArray< aeSignalValue< V >* > m_signals;
};

//------------------------------------------------------------------------------
// aeSignalValue member functions
//------------------------------------------------------------------------------
template < typename V >
aeSignalValue< V >::aeSignalValue() :
  m_valSet( false ),
  m_val( V() )
{}

template < typename V >
aeSignalValue< V >::aeSignalValue( const V& val ) :
  m_valSet( true ),
  m_val( val )
{}

// @TODO: Const
template < typename V >
bool aeSignalValue< V >::HasValue()
{
  return m_valSet;
}

//------------------------------------------------------------------------------
// aeSignal member functions
//------------------------------------------------------------------------------
template < typename T, typename V >
aeSignal< T, V >::aeSignal() :
  m_obj( nullptr ),
  m_fn( nullptr ),
  m_fnVal( nullptr ),
  m_isCalled( false )
{}

template < typename T, typename V >
aeSignal< T, V >::aeSignal( T* obj, void ( T::* fn ) () ) :
  m_obj( obj ),
  m_fn( fn ),
  m_fnVal( nullptr ),
  m_isCalled( false )
{}

template < typename T, typename V >
aeSignal< T, V >::aeSignal( T* obj, void ( T::* fn ) ( V ) ) :
  m_obj( obj ),
  m_fn( nullptr ),
  m_fnVal( fn ),
  m_isCalled( false )
{}

template < typename T, typename V >
aeSignal< T, V >::aeSignal( T* obj, void ( T::* fn ) ( V ), const V& value ) :
  aeSignalValue< V >( value ),
  m_obj( obj ),
  m_fn( nullptr ),
  m_fnVal( fn ),
  m_isCalled( false )
{}

template < typename T, typename V >
aeSignal< T, V >::aeSignal( aeRef< T >& ref, void ( T::* fn ) () ) :
  m_obj( nullptr ),
  m_ref( ref ),
  m_fn( fn ),
  m_fnVal( nullptr ),
  m_isCalled( false )
{}

template < typename T, typename V >
aeSignal< T, V >::aeSignal( aeRef< T >& ref, void ( T::* fn ) ( V ) ) :
  m_obj( nullptr ),
  m_ref( ref ),
  m_fn( nullptr ),
  m_fnVal( fn ),
  m_isCalled( false )
{}

template < typename T, typename V >
aeSignal< T, V >::aeSignal( aeRef< T >& ref, void ( T::* fn ) ( V ), const V& value ) :
  aeSignalValue< V >( value ),
  m_obj( nullptr ),
  m_ref( ref ),
  m_fn( nullptr ),
  m_fnVal( fn ),
  m_isCalled( false )
{}

template < typename T, typename V >
aeSignal< T, V >::~aeSignal()
{
  AE_ASSERT_MSG( !m_isCalled, "Signal call destroyed itself" );
}

template < typename T, typename V >
bool aeSignal< T, V >::Send()
{
  AE_ASSERT_MSG( !m_isCalled, "aeSignal::Send() called recursively" );

  T* obj = m_obj;
  obj = obj ? obj : (T*)m_ref;

  if ( !obj )
  {
    return false;
  }

  if ( m_fn )
  {
    m_isCalled = true;

    ( obj->*m_fn )();

    m_isCalled = false;
    return true;
  }
  else if ( m_fnVal && aeSignalValue< V >::m_valSet )
  {
    m_isCalled = true;

    ( obj->*m_fnVal )( aeSignalValue< V >::m_val );

    m_isCalled = false;
    return true;
  }
  else
  {
    return false;
  }
}

template < typename T, typename V >
bool aeSignal< T, V >::Send( const V& value )
{
  AE_ASSERT_MSG( !m_isCalled, "aeSignal::Send() called recursively" );

  T* obj = m_obj;
  obj = obj ? obj : (T*)m_ref;
  
  if ( !obj || !m_fnVal )
  {
    return false;
  }

  m_isCalled = true;

  ( obj->*m_fnVal )( value );

  m_isCalled = false;
  return true;
}

// @TODO: Const
template < typename T, typename V >
void* aeSignal< T, V >::GetObj()
{
  T* obj = m_obj;
  obj = obj ? obj : (T*)m_ref;
  return obj;
}

//------------------------------------------------------------------------------
// aeSignalList member functions
//------------------------------------------------------------------------------
template < typename V >
aeSignalList< V >::~aeSignalList()
{
  for ( uint32_t i = 0; i < m_signals.Length(); i++ )
  {
    aeAlloc::Release( m_signals[ i ] );
  }
}

template < typename V >
template < typename T, typename Fn >
void aeSignalList< V >::Add( T* obj, Fn fn )
{
  if ( !obj )
  {
    return;
  }

  auto findFn = [ obj ]( aeSignalBase* signal )
  {
    // @HACK: Should also check fn, so an object can register multiple functions at a time
    return signal->GetObj() == obj;
  };
  int32_t signalIndex = m_signals.FindFn( findFn );
  if ( signalIndex >= 0 )
  {
    *m_signals[ signalIndex ] = aeSignal< T, V >( obj, fn );
    return;
  }

  m_signals.Append( aeAlloc::Allocate< aeSignal< T, V > >( obj, fn ) );
}

template < typename V >
template < typename T, typename Fn >
void aeSignalList< V >::Add( aeRef< T > ref, Fn fn )
{
  T* obj = (T*)ref;
  if ( !obj )
  {
    return;
  }

  auto findFn = [ obj ]( aeSignalBase* signal )
  {
    // @HACK: Should also check fn, so an object can register multiple functions at a time
    return signal->GetObj() == obj;
  };
  int32_t signalIndex = m_signals.FindFn( findFn );
  if ( signalIndex >= 0 )
  {
    *m_signals[ signalIndex ] = aeSignal< T, V >( ref, fn );
    return;
  }

  m_signals.Append( aeAlloc::Allocate< aeSignal< T, V > >( ref, fn ) );
}

template < typename V >
void aeSignalList< V >::Remove( void* obj )
{
  auto fn = [ obj ]( aeSignalBase* base )
  {
    void* o = base->GetObj();
    return !o || ( o == obj );
  };

  int32_t index = 0;
  while ( ( index = m_signals.FindFn( fn ) ) >= 0 )
  {
    aeAlloc::Release( m_signals[ index ] );
    m_signals.Remove( index ); // Remove signals for the given obj and any signals with null references
  }
}

template < typename V >
void aeSignalList< V >::Send()
{
  auto fn = []( aeSignalBase* signal )
  {
    return !signal->GetObj();
  };

  int32_t index = 0;
  while ( ( index = m_signals.FindFn( fn ) ) >= 0 )
  {
    aeAlloc::Release( m_signals[ index ] );
    m_signals.Remove( index ); // Remove null references before send
  }

  for ( uint32_t i = 0; i < m_signals.Length(); i++ )
  {
    aeSignalValue< V >* signal = m_signals[ i ];
    ((aeSignalBase*)signal)->Send();
  }
}

template < typename V >
template < typename T >
void aeSignalList< V >::Send( const T& value )
{
  auto fn = []( aeSignalBase* signal )
  {
    return !signal->GetObj();
  };

  int32_t index = -1;
  while ( ( index = m_signals.FindFn( fn ) ) >= 0 )
  {
    aeAlloc::Release( m_signals[ index ] );
    m_signals.Remove( index ); // Remove null references before send
  }

  for ( uint32_t i = 0; i < m_signals.Length(); i++ )
  {
    aeSignalValue< V >* signal = m_signals[ i ];
    if ( !signal->Send( value ) )
    {
      ((aeSignalBase*)signal)->Send();
    }
  }
}

template < typename V >
uint32_t aeSignalList< V >::Length() const
{
  return m_signals.Length();
}

#endif
//------------------------------------------------------------------------------
// aeInitializer.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEINITIALIZER_H
#define AEINITIALIZER_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeInitInfo class
//------------------------------------------------------------------------------
template < typename T >
class aeInitInfo
{
public:
  aeInitInfo() {}
  aeInitInfo( std::function< void( T* ) > i, std::function< void( T* ) > t ) : m_init( i ), m_term( t ) {}
  aeInitInfo( const aeInitInfo& i ) : m_init( i.m_init ), m_term( i.m_term ) {}
  
  void Initialize( T* obj ) { if ( m_init ) { m_init( obj ); } }
  void Terminate( T* obj ) { if ( m_term ) { m_term( obj ); } }

private:
  std::function< void( T* ) > m_init;
  std::function< void( T* ) > m_term;
};

//------------------------------------------------------------------------------
// aeInitializer class
//------------------------------------------------------------------------------
template < typename T >
class aeInitializer
{
public:
  aeInitializer( const aeInitInfo< T >& initInfo ) : m_initInfo( initInfo ) { m_initInfo.Initialize( &m_obj ); }
  ~aeInitializer() { m_initInfo.Terminate( &m_obj ); }

  T& Get() { return m_obj; }
  const T& Get() const { return m_obj; }

private:
  aeInitializer( aeInitializer& ) = delete;
  aeInitializer& operator= ( aeInitializer& ) = delete;

  aeInitInfo< T > m_initInfo;
  T m_obj;
};

#endif
//------------------------------------------------------------------------------
// aeSparseGrid.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AESPARSEGRID_H
#define AESPARSEGRID_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeSparseGridZone class
//------------------------------------------------------------------------------
template < typename T, int32_t DimX, int32_t DimY, int32_t DimZ >
class aeSparseGridZone
{
public:
  // aeSparseGrid interface start
  void SetZoneInfo( aeInt3 offset ) {}

  void Set( aeInt3 pos, const T& value ) { m_values[ pos.z ][ pos.y ][ pos.x ] = value; }
  T& Get( aeInt3 pos ) { return m_values[ pos.z ][ pos.y ][ pos.x ]; }
  const T& Get( aeInt3 pos ) const { return m_values[ pos.z ][ pos.y ][ pos.x ]; }

  static aeInt3 GetSize() { return aeInt3( DimX, DimY, DimZ ); }
  typedef T GridType;
  // aeSparseGrid interface end

private:
  T m_values[ DimZ ][ DimY ][ DimX ] = {}; // Default initialization
};

//------------------------------------------------------------------------------
// aeSparseGrid class
//------------------------------------------------------------------------------
template < typename Z >
class aeSparseGrid
{
public:
  aeSparseGrid() {}
  aeSparseGrid( aeInitInfo< Z > initInfo ) : m_initInfo( initInfo ) {}
  ~aeSparseGrid() { Clear(); }

  void Reset( const aeInitInfo< Z >& initInfo ) { Clear(); m_initInfo = initInfo; }
  void Clear();

  void Set( aeInt3 pos, const typename Z::GridType& value );
  typename Z::GridType* TryGet( aeInt3 pos );
  const typename Z::GridType* TryGet( aeInt3 pos ) const;

  uint32_t Length() const;
  Z* GetZone( uint32_t i );
  const Z* GetZone( uint32_t i ) const;
  Z* GetZone( aeInt3 pos );
  const Z* GetZone( aeInt3 pos ) const;

private:
  aeSparseGrid( const aeSparseGrid& ) = delete;
  aeSparseGrid& operator=( const aeSparseGrid& ) = delete;

  aeInt3 m_GetSlot( aeInt3 pos ) const;
  aeInt3 m_GetLocal( aeInt3 pos ) const;

  aeInitInfo< Z > m_initInfo;
  aeMap< aeInt3, aeInitializer< Z >* > m_zones;
};

//------------------------------------------------------------------------------
// aeSparseGrid member functions
//------------------------------------------------------------------------------
template < typename Z >
aeInt3 aeSparseGrid< Z >::m_GetSlot( aeInt3 pos ) const
{
  const aeInt3 size = Z::GetSize();
  return aeInt3(
    aeMath::Floor( (float)pos.x / size.x ),
    aeMath::Floor( (float)pos.y / size.y ),
    aeMath::Floor( (float)pos.z / size.z )
  );
}

template < typename Z >
aeInt3 aeSparseGrid< Z >::m_GetLocal( aeInt3 pos ) const
{
  const aeInt3 size = Z::GetSize();
  return aeInt3(
    aeMath::Mod( pos.x, size.x ),
    aeMath::Mod( pos.y, size.y ),
    aeMath::Mod( pos.z, size.z )
  );
}

template < typename Z >
void aeSparseGrid< Z >::Clear()
{
  uint32_t zoneCount = m_zones.Length();
  for ( uint32_t i = 0; i < zoneCount; i++ )
  {
    aeAlloc::Release( m_zones.GetValue( i ) );
  }
  m_zones.Clear();
}

template < typename Z >
void aeSparseGrid< Z >::Set( aeInt3 pos, const typename Z::GridType& value )
{
  aeInt3 slot = m_GetSlot( pos );
  aeInitializer< Z >* zone = nullptr;
  if ( !m_zones.TryGet( slot, &zone ) )
  {
    const aeInt3 size = Z::GetSize();
    zone = aeAlloc::Allocate< aeInitializer< Z > >( m_initInfo );
    zone->Get().SetZoneInfo( slot * size );
    m_zones.Set( slot, zone );
  }

  aeInt3 localPos = m_GetLocal( pos );
  zone->Get().Set( localPos, value );
}

// @NOTE: const and non-const TryGet() must be implemented seprately so the correct Z::GridType::Get() is called
template < typename Z >
typename Z::GridType* aeSparseGrid< Z >::TryGet( aeInt3 pos )
{
  aeInt3 slot = m_GetSlot( pos );

  aeInitializer< Z >* zone = nullptr;
  if ( m_zones.TryGet( slot, &zone ) )
  {
    aeInt3 localPos = m_GetLocal( pos );
    return &zone->Get().Get( localPos );
  }

  return nullptr;
}

template < typename Z >
const typename Z::GridType* aeSparseGrid< Z >::TryGet( aeInt3 pos ) const
{
  aeInt3 slot = m_GetSlot( pos );

  aeInitializer< Z >* zone = nullptr;
  if ( m_zones.TryGet( slot, &zone ) )
  {
    aeInt3 localPos = m_GetLocal( pos );
    return &zone->Get().Get( localPos );
  }

  return nullptr;
}

template < typename Z >
uint32_t aeSparseGrid< Z >::Length() const
{
  return m_zones.Length();
}

template < typename Z >
Z* aeSparseGrid< Z >::GetZone( uint32_t i )
{
  return &m_zones.GetValue( i )->Get();
}

template < typename Z >
const Z* aeSparseGrid< Z >::GetZone( uint32_t i ) const
{
  return &m_zones.GetValue( i )->Get();
}

template < typename Z >
Z* aeSparseGrid< Z >::GetZone( aeInt3 pos )
{
  aeInt3 slot = m_GetSlot( pos );
  aeInitializer< Z >* zone = nullptr;
  m_zones.TryGet( slot, &zone );
  return zone ? &zone->Get() : nullptr;
}

template < typename Z >
const Z* aeSparseGrid< Z >::GetZone( aeInt3 pos ) const
{
  aeInt3 slot = m_GetSlot( pos );
  aeInitializer< Z >* zone = nullptr;
  m_zones.TryGet( slot, &zone );
  return zone ? &zone->Get() : nullptr;
}

#endif
//------------------------------------------------------------------------------
// aeHotSpot.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AE_HOTSPOT
#define AE_HOTSPOT

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// HotSpotWorld class
//------------------------------------------------------------------------------
class HotSpotWorld
{
public:
  void Initialize( float timeStep );
  void Update( float dt );

  // 1) Tiles - Setup tile properties and enable collision
  void SetTileProperties( uint32_t type, uint32_t mask );
  uint32_t GetTileProperties( uint32_t type ) const;
  void SetTileFluidDensity( uint32_t type, float density ); // water is 1000 kg/m^3
  float GetTileFluidDensity( uint32_t type ) const;
  void SetCollisionMask( uint32_t mask );
  uint32_t GetCollisionMask() const;

  // 2) Map - Populate map tiles
  void LoadTiles( const uint32_t* tiles, uint32_t width, uint32_t height, bool flipVertical );
  void SetTile( aeInt2 pos, uint32_t type );
  uint32_t GetTile( aeInt2 pos ) const;

  // 3) Objects - Create objects for simulation
  class HotSpotObject* CreateObject();
  class HotSpotObject* GetObject( uint32_t index );
  uint32_t GetObjectCount() const;

private:
  float m_timeStep = 0.0f;
  float m_timeAccumulator = 0.0f;

  aeSparseGrid< aeSparseGridZone< uint32_t, 16, 16, 1 > > m_tiles;

  aeMap< uint32_t, uint32_t > m_tileProperties;
  aeMap< uint32_t, float > m_tileDensity;
  uint32_t m_collisionMask = 0;

  aeArray< class HotSpotObject* > m_objects;

public:
  static aeInt2 _GetTilePos( aeFloat2 pos );
};

//------------------------------------------------------------------------------
// HotSpotObject class
//------------------------------------------------------------------------------
class HotSpotObject
{
public:
  void SetMass( float kilograms ); // Average human: 155lb ~= 70kg
  void SetRestitution( float groundPercent, float wallPercent ); // Percent of velocity kept on collision
  void SetVolume( float meters ); // meters^3: A humans volume is roughly their weight in kg/1050 (slightly denser than water). Volume is required for correct buoyancy behavior

  float GetMass() const;

  void Warp( aeFloat2 meters ); // Position in meters
  void SetVelocity( aeFloat2 metersPerSecond ); // Distance traveled per second
  // 1 Newton: Force required to accelerate an object with a mass of 1 kg 1 m/s^2
  void AddForce( aeFloat2 newtons ); // Apply a regular force to the object (scaled by frame time)
  void AddImpulse( aeFloat2 newtons ); // Apply a force and change velocity directly (without respect to frame time)
  void AddGravity( aeFloat2 acceleration ); // Gravitational acceleration, call each frame

  aeFloat2 GetPosition() const;
  aeFloat2 GetVelocity() const;
  bool IsOnGround() const;

  struct CollisionInfo
  {
    aeInt2 position;
    aeInt2 normal;
    uint32_t tile;
    uint32_t properties;
  };
  aeSignalList< const CollisionInfo* > onCollision;

private:
  friend HotSpotWorld;
  void Update( HotSpotWorld* world, float dt );
  bool m_CheckCollision( const HotSpotWorld* world, aeInt2 dir );
  bool m_TestSide( const HotSpotWorld* world, aeFloat2 p0, aeFloat2 p1, aeFloat2* pOut );

  aeFloat2 m_position = aeFloat2( 0.0f );
  aeFloat2 m_velocity = aeFloat2( 0.0f );
  aeFloat2 m_forces = aeFloat2( 0.0f );
  aeFloat2 m_gravity = aeFloat2( 0.0f );
  float m_mass = 1.0f;
  float m_groundRestitution = 0.0f;
  float m_wallRestitution = 0.3f;
  float m_volume = 1.0f;
  float m_airTimer = 0.0f;
};

#endif
//------------------------------------------------------------------------------
// aeImage.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEIMAGE_H
#define AEIMAGE_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeImage
//------------------------------------------------------------------------------
namespace ae
{
  class Image
  {
  public:
    enum class Extension
    {
      PNG
    };

    enum class Interpolation
    {
      Nearest,
      Linear,
      Cosine
    };

    enum class Format
    {
      Auto,
      R,
      RG,
      RGB,
      RGBA
    };

    void LoadRaw( const uint8_t* data, uint32_t width, uint32_t height, Format format, Format storage = Format::Auto );
    bool LoadFile( const void* file, uint32_t length, Extension extension, Format storage = Format::Auto );

    uint32_t GetWidth() const { return m_width; }
    uint32_t GetHeight() const { return m_height; }
    uint32_t GetChannels() const { return m_channels; }

    aeColor Get( aeInt2 pixel ) const;
    aeColor Get( aeFloat2 pixel, Interpolation interpolation ) const;

  private:
    aeArray< uint8_t > m_data;
    int32_t m_width = 0;
    int32_t m_height = 0;
    uint32_t m_channels = 0;
  };
}

#endif
//------------------------------------------------------------------------------
// aeInput.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEINPUT_H
#define AEINPUT_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Input types
//------------------------------------------------------------------------------
enum InputType
{
  kInputType_Up,
  kInputType_Down,
  kInputType_Left,
  kInputType_Right,

  kInputType_Start,
  kInputType_Select,

  kInputType_A,
  kInputType_B,
  kInputType_X,
  kInputType_Y,
  kInputType_L,
  kInputType_R,

  kInputType_MouseLeft,
  kInputType_MouseRight,
  kInputType_MouseMiddle,

  kInputType_Space,
  kInputType_Control,
  kInputType_Shift,
  kInputType_Delete,
  kInputType_Tilde,
  kInputType_Escape,

  kInputTypeCount
};

enum class aeBatteryLevel
{
  None,
  Empty,
  Low,
  Medium,
  Full,
  Wired
};

//------------------------------------------------------------------------------
// aeKey enum
// Based on:
// https://hg.libsdl.org/SDL/file/eff2d605bef5/include/SDL_scancode.h
// https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf
//------------------------------------------------------------------------------
enum class aeKey
{
  Unknown = 0,

  A = 4,
  B = 5,
  C = 6,
  D = 7,
  E = 8,
  F = 9,
  G = 10,
  H = 11,
  I = 12,
  J = 13,
  K = 14,
  L = 15,
  M = 16,
  N = 17,
  O = 18,
  P = 19,
  Q = 20,
  R = 21,
  S = 22,
  T = 23,
  U = 24,
  V = 25,
  W = 26,
  X = 27,
  Y = 28,
  Z = 29,

  Num1 = 30,
  Num2 = 31,
  Num3 = 32,
  Num4 = 33,
  Num5 = 34,
  Num6 = 35,
  Num7 = 36,
  Num8 = 37,
  Num9 = 38,
  Num0 = 39,

  Enter = 40,
  Escape = 41,
  Backspace = 42,
  Tab = 43,
  Space = 44,

  Minus = 45,
  Equals = 46,
  LeftBracket = 47,
  RightBracket = 48,
  Backslash = 49,

  Semicolon = 51,
  Apostrophe = 52,
  Tilde = 53,
  Comma = 54,
  Period = 55,
  Slash = 56,
  CapsLock = 57,

  F1 = 58,
  F2 = 59,
  F3 = 60,
  F4 = 61,
  F5 = 62,
  F6 = 63,
  F7 = 64,
  F8 = 65,
  F9 = 66,
  F10 = 67,
  F11 = 68,
  F12 = 69,

  PrintScreen = 70,
  ScrollLock = 71,
  Pause = 72,

  Insert = 73,
  Home = 74,
  PageUp = 75,
  Delete = 76,
  End = 77,
  PageDown = 78,

  Right = 79,
  Left = 80,
  Down = 81,
  Up = 82,

  NumLock = 84,
  NumPadDivide = 84,
  NumPadMultiply = 85,
  NumPadMinus = 86,
  NumPadPlus = 87,
  NumPadEnter = 88,
  NumPad1 = 89,
  NumPad2 = 90,
  NumPad3 = 91,
  NumPad4 = 92,
  NumPad5 = 93,
  NumPad6 = 94,
  NumPad7 = 95,
  NumPad8 = 96,
  NumPad9 = 97,
  NumPad0 = 98,
  NumPadPeriod = 99,
  NumPadEquals = 103,

  LeftControl = 224,
  LeftShift = 225,
  LeftAlt = 226,
  LeftSuper = 227,
  RightControl = 228,
  RightShift = 229,
  RightAlt = 230,
  RightSuper = 231
};

const uint32_t kKeyCount = 256;

//------------------------------------------------------------------------------
// InputState class
//------------------------------------------------------------------------------
class InputState
{
public:
  InputState();
  bool Get( InputType type ) const;
  const char* GetName( InputType type ) const;
  bool Get( aeKey key ) const;

  bool gamepad;
  aeBatteryLevel gamepadBattery;

  aeFloat2 leftAnalog;
  aeFloat2 rightAnalog;
  aeInt2 dpad;

  bool up;
  bool down;
  bool left;
  bool right;

  bool start;
  bool select;

  bool a;
  bool b;
  bool x;
  bool y;
  bool l;
  bool r;

  bool mouseLeft;
  bool mouseRight;
  bool mouseMiddle;

  bool space;
  bool ctrl;
  bool shift;
  bool del;
  bool tilde;
  bool esc;

  aeInt2 mousePixelPos;
  int32_t scroll;
  bool windowFocus;

  bool exit; // Window 'X' etc

private:
  friend class aeInput;
  bool m_keys[ kKeyCount ];
};

//------------------------------------------------------------------------------
// aeInput class
//------------------------------------------------------------------------------
class aeInput
{
public:
  aeInput();
  void Initialize( class aeWindow* window = nullptr );
  void Terminate();
  void Pump();

  const InputState* GetState() const { return &m_input; }
  const InputState* GetPrevState() const { return &m_prevInput; }

  void SetTextMode( bool enabled );
  bool GetTextMode() const { return m_textMode; }
  void SetText( const char* text ) { m_text = text; }
  const char* GetText() const { return m_text.c_str(); }
  const char* GetTextInput() const { return m_textInput.Length() ? &m_textInput[ 0 ] : ""; }

  void SetMouseCaptured( bool captured );
  bool GetMouseCaptured() const { return m_mouseCaptured; }

private:
  class aeWindow* m_window;

  aeMap< uint32_t, bool* > m_keyMap;
  
  InputState m_input;
  InputState m_prevInput;

  bool m_textMode;
  aeStr512 m_text;
  aeArray< char > m_textInput;

  bool m_mouseCaptured;
  bool m_firstPump;

  struct _SDL_Joystick* m_joystickHandle;
#if !_AE_EMSCRIPTEN_
  struct _SDL_GameController* m_controller;
#endif
  uint32_t m_buttonCount;
  uint32_t m_hatCount;
  uint32_t m_axesCount;
};

#endif
//------------------------------------------------------------------------------
// aeList.h
// Intrusive circularly linked list
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AELIST_H
#define AELIST_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Types
//------------------------------------------------------------------------------
template < typename T >
class aeList;

//------------------------------------------------------------------------------
// aeLinkedList class
//------------------------------------------------------------------------------
template < typename T >
class aeListNode
{
public:
  aeListNode( T* owner );
  ~aeListNode();

  void Remove();

  T* GetFirst();
  T* GetNext();
  T* GetPrev();
  T* GetLast();

  const T* GetFirst() const;
  const T* GetNext() const;
  const T* GetPrev() const;
  const T* GetLast() const;

  aeList< T >* GetList();
  const aeList< T >* GetList() const;

private:
  friend class aeList< T >;
  
  // @NOTE: These operations don't make sense when either node is in a list,
  // to avoid a potentially hard to diagnose random assert, assignment is
  // disabled altogether
  aeListNode( aeListNode& ) = delete;
  void operator = ( aeListNode& ) = delete;

  aeList< T >* m_root;
  aeListNode* m_next;
  aeListNode* m_prev;
  T* m_owner;
};

//------------------------------------------------------------------------------
// aeList class
//------------------------------------------------------------------------------
template < typename T >
class aeList
{
public:
  aeList();
  ~aeList();

  void Append( aeListNode< T >& node );

  T* GetFirst();
  T* GetLast();

  const T* GetFirst() const;
  const T* GetLast() const;

  template < typename U > T* Find( const U& value );
  template < typename Fn > T* FindFn( Fn predicateFn );

  uint32_t Length() const;

private:
  friend class aeListNode< T >;
  
  // @NOTE: Disable assignment. Assigning a list to another list technically makes sense,
  // but could result in unexpected orphaning of list nodes. Additionally disabing these
  // operations is consistent with list node.
  aeList( aeList& ) = delete;
  void operator = ( aeList& ) = delete;

  aeListNode< T >* m_first;
};

//------------------------------------------------------------------------------
// aeLinkedList member functions
//------------------------------------------------------------------------------
template < typename T >
aeListNode< T >::aeListNode( T* owner )
{
  m_root = nullptr;
  m_next = this;
  m_prev = this;
  m_owner = owner;
}

template < typename T >
aeListNode< T >::~aeListNode()
{
  Remove();
}

template < typename T >
void aeListNode< T >::Remove()
{
  if ( !m_root )
  {
    return;
  }

  AE_ASSERT( m_root->m_first );
  if ( m_root->m_first == this )
  {
    if ( m_next == this )
    {
      // Last node in list
      m_root->m_first = nullptr;
    }
    else
    {
      // Was head. Set next as head.
      m_root->m_first = m_next;
    }
  }

  m_next->m_prev = m_prev;
  m_prev->m_next = m_next;

  m_root = nullptr;
  m_next = this;
  m_prev = this;
}

template < typename T >
T* aeListNode< T >::GetFirst()
{
  return const_cast< T* >( const_cast< const aeListNode< T >* >( this )->GetFirst() );
}

template < typename T >
T* aeListNode< T >::GetNext()
{
  return const_cast< T* >( const_cast< const aeListNode< T >* >( this )->GetNext() );
}

template < typename T >
T* aeListNode< T >::GetPrev()
{
  return const_cast< T* >( const_cast< const aeListNode< T >* >( this )->GetPrev() );
}

template < typename T >
T* aeListNode< T >::GetLast()
{
  return const_cast<T*>( const_cast<const aeListNode< T >*>( this )->GetLast() );
}

template < typename T >
const T* aeListNode< T >::GetFirst() const
{
  return m_root ? m_root->GetFirst() : nullptr;
}

template < typename T >
const T* aeListNode< T >::GetNext() const
{
  if ( !m_root || m_root->m_first == m_next )
  {
    return nullptr;
  }
  return m_next->m_owner;
}

template < typename T >
const T* aeListNode< T >::GetPrev() const
{
  if ( !m_root || m_root->m_first == this )
  {
    return nullptr;
  }
  return m_prev->m_owner;
}

template < typename T >
const T* aeListNode< T >::GetLast() const
{
  return m_root ? m_root->GetLast() : nullptr;
}

template < typename T >
aeList< T >* aeListNode< T >::GetList()
{
  return m_root;
}

template < typename T >
const aeList< T >* aeListNode< T >::GetList() const
{
  return m_root;
}

//------------------------------------------------------------------------------
// aeList member functions
//------------------------------------------------------------------------------
template < typename T >
aeList< T >::aeList() : m_first( nullptr )
{}

template < typename T >
aeList< T >::~aeList()
{
  while ( m_first )
  {
    m_first->Remove();
  }
}

template < typename T >
void aeList< T >::Append( aeListNode< T >& node )
{
  if ( m_first )
  {
    node.Remove();

    node.m_root = this;

    node.m_next = m_first;
    node.m_prev = m_first->m_prev;

    node.m_next->m_prev = &node;
    node.m_prev->m_next = &node;
  }
  else
  {
    m_first = &node;
    node.m_root = this;
  }
}

template < typename T >
T* aeList< T >::GetFirst()
{
  return m_first ? m_first->m_owner : nullptr;
}

template < typename T >
T* aeList< T >::GetLast()
{
  return m_first ? m_first->m_prev->m_owner : nullptr;
}

template < typename T >
const T* aeList< T >::GetFirst() const
{
  return m_first ? m_first->m_owner : nullptr;
}

template < typename T >
const T* aeList< T >::GetLast() const
{
  return m_first ? m_first->m_prev->m_owner : nullptr;
}

template < typename T >
template < typename U >
T* aeList< T >::Find( const U& value )
{
  if ( !m_first )
  {
    return nullptr;
  }

  aeListNode< T >* current = m_first;
  do
  {
    if ( *( current->m_owner ) == value )
    {
      return current->m_owner;
    }
    current = current->m_next;
  } while ( current != m_first );

  return nullptr;
}

template < typename T >
template < typename Fn >
T* aeList< T >::FindFn( Fn predicateFn )
{
  if ( !m_first )
  {
    return nullptr;
  }

  aeListNode< T >* current = m_first;
  do
  {
    if ( predicateFn( current->m_owner ) )
    {
      return current->m_owner;
    }
    current = current->m_next;
  } while ( current != m_first );

  return nullptr;
}

template < typename T >
uint32_t aeList< T >::Length() const
{
  if ( !m_first )
  {
    return 0;
  }

  // @TODO: Should be constant time
  uint32_t count = 1;
  aeListNode< T >* current = m_first;
  while ( current->m_next != m_first )
  {
    current = current->m_next;
    count++;
  }

  return count;
}

#endif
//------------------------------------------------------------------------------
// aeInventoryGrid.h
// 2D sparse grid which stores elements that occupy an arbitrary number of cells
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEINVENTORYGRID_H
#define AEINVENTORYGRID_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeInventoryGrid class
//------------------------------------------------------------------------------
template < typename T >
class aeInventoryGrid
{
public:
  ~aeInventoryGrid();

  void Set( T& value, aeRectInt rect );
  void Set( T& value, aeInt2* cells, uint32_t cellCount );

  T* TryGet( aeInt2 pos );
  bool TryGet( aeInt2 pos, T* valueOut );
  const T* TryGet( aeInt2 pos ) const;

  void Remove( aeInt2 pos );
  void Remove( const T& value );

  uint32_t Length() const;

private:
  struct Shape
  {
    Shape() : node( this ) {}

    aeListNode< Shape > node;
    aeArray< aeInt2 > cells;
    T value;
  };

  aeList< Shape > m_shapeList;
};

template < typename T >
aeInventoryGrid< T >::~aeInventoryGrid()
{
  while ( m_shapeList.GetLast() )
  {
    aeAlloc::Release( m_shapeList.GetLast() );
  }
}

template < typename T >
void aeInventoryGrid< T >::Set( T& value, aeRectInt rect )
{
  aeArray< aeInt2 > cells( rect.w * rect.h );
  for ( uint32_t y = 0; y < rect.h; y++ )
  {
    for ( uint32_t x = 0; x < rect.w; x++ )
    {
      cells.Append( aeInt2( rect.x + x, rect.y + y ) );
    }
  }
  Set( value, &( cells[ 0 ] ), cells.Length() );
}

template < typename T >
void aeInventoryGrid< T >::Set( T& value, aeInt2* cells, uint32_t cellCount )
{
  for ( uint32_t i = 0; i < cellCount; i++ )
  {
    T* other = TryGet( cells[ i ] );
    AE_ASSERT_MSG( !other, "Cell # already occupied by #", cells[ i ], other );
  }

  Shape* shape = aeAlloc::Allocate< Shape >();
  AE_ASSERT( shape );

  shape->value = value;
  shape->cells.Append( cells, cellCount );
  m_shapeList.Append( shape->node );
}

template < typename T >
T* aeInventoryGrid< T >::TryGet( aeInt2 pos )
{
  return const_cast<T*>( const_cast<const aeInventoryGrid< T >*>( this )->TryGet( pos ) );
}

template < typename T >
bool aeInventoryGrid< T >::TryGet( aeInt2 pos, T* valueOut )
{
  const T* result = TryGet( pos );
  if ( result )
  {
    *valueOut = *result;
    return true;
  }
  return false;
}

template < typename T >
const T* aeInventoryGrid< T >::TryGet( aeInt2 pos ) const
{
  const Shape* shape = m_shapeList.GetFirst();
  while ( shape )
  {
    if ( shape->cells.Find( pos ) >= 0 )
    {
      return &shape->value;
    }
    shape = shape->node.GetNext();
  }

  return nullptr;
}

template < typename T >
void aeInventoryGrid< T >::Remove( aeInt2 pos )
{
  if ( m_shapeList.Length() == 0 )
  {
    return;
  }

  auto fn = [ pos ]( Shape* shape )
  {
    return ( shape->cells.Find( pos ) >= 0 );
  };
  Shape* shape = m_shapeList.FindFn( fn );
  if ( shape )
  {
    aeAlloc::Release( shape );
  }
}

template < typename T >
void aeInventoryGrid< T >::Remove( const T& value )
{
  AE_ASSERT( m_shapeList.Length() );

  auto fn = [ value ]( Shape* shape )
  {
    return ( shape->value == value );
  };
  Shape* shape = m_shapeList.FindFn( fn );
  AE_ASSERT( shape );
  aeAlloc::Release( shape );
}

template < typename T >
uint32_t aeInventoryGrid< T >::Length() const
{
  return m_shapeList.Length();
}

#endif
//------------------------------------------------------------------------------
// aeMesh.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEMESH_H
#define AEMESH_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeMesh types
//------------------------------------------------------------------------------
struct aeMeshVertex
{
  aeFloat4 position;
  aeFloat4 normal;
  aeFloat2 tex[ 4 ];
  aeColor color[ 4 ];
};

typedef uint16_t aeMeshIndex;

//------------------------------------------------------------------------------
// aeMesh class
//------------------------------------------------------------------------------
class aeMesh
{
public:
  bool LoadFileData( const uint8_t* data, uint32_t length, const char* extension, bool skipMeshOptimization = false );
  void Transform( aeFloat4x4 transform );

  const aeMeshVertex* GetVertices() const;
  const aeMeshIndex* GetIndices() const;
  uint32_t GetVertexCount() const;
  uint32_t GetIndexCount() const;

private:
  aeArray< aeMeshVertex > m_vertices;
  aeArray< aeMeshIndex > m_indices;
};

#endif
//------------------------------------------------------------------------------
// aeNet.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AENET_H
#define AENET_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// AetherUuid class
//------------------------------------------------------------------------------
struct AetherUuid
{
  AetherUuid() = default;
  AetherUuid( const char* str );
  
  bool operator==( const AetherUuid& other ) const { return memcmp( uuid, other.uuid, 16 ) == 0; }
  bool operator!=( const AetherUuid& other ) const { return memcmp( uuid, other.uuid, 16 ) != 0; }

  static AetherUuid Generate();
  static AetherUuid Zero();

  void ToString( char* str, uint32_t max ) const;

  uint8_t uuid[ 16 ];
};

std::ostream& operator<<( std::ostream& os, const AetherUuid& uuid );

inline void Serialize( aeBinaryStream* stream, AetherUuid* uuid )
{
	stream->SerializeRaw( uuid->uuid, sizeof( uuid->uuid ) );
}

inline void Serialize( aeBinaryStream* stream, const AetherUuid* uuid )
{
  stream->SerializeRaw( uuid->uuid, sizeof( uuid->uuid ) );
}

//------------------------------------------------------------------------------
// aeNetData class
//------------------------------------------------------------------------------
class aeNetData
{
public:
  struct Msg
  {
    const uint8_t* data;
    uint32_t length;
  };

  // General
  bool IsAuthority() const { return m_local; }
	
  // Server
  void SetSyncData( const void* data, uint32_t length );
  void SendMessage( const void* data, uint32_t length );

  // Client
  const uint8_t* GetInitData() const;
  uint32_t InitDataLength() const;

  const uint8_t* GetSyncData() const;
  uint32_t SyncDataLength() const;
  void ClearSyncData(); // Call to clear local received data. Check ( Length() > 0 ) for new data.

  bool PumpMessages( Msg* msgOut );

  bool IsPendingDelete() const;

private:
  // @TODO: Expose internals in a safer way
  friend class aeNetReplicaClient;
  friend class aeNetReplicaServer;
  friend class aeNetReplicaDB;

  void m_SetLocal() { m_local = true; }
  void m_SetClientData( const uint8_t* data, uint32_t length );
  void m_ReceiveMessages( const uint8_t* data, uint32_t length );
  void FlagForDeletion() { m_isPendingDelete = true; }
  
  void m_UpdateHash();
  bool m_Changed() const { return m_hash != m_prevHash; }

  bool m_local = false;
  aeArray< uint8_t > m_initData;
  aeArray< uint8_t > m_data;

  aeArray< uint8_t > m_messageDataOut;
  aeArray< uint8_t > m_messageDataIn;
  uint32_t m_messageDataInOffset = 0;

  uint32_t m_hash = 0;
  uint32_t m_prevHash = 0;
  bool m_isPendingDelete = false;
public:
  // Internal
  AE_REFABLE( aeNetData );
};

//------------------------------------------------------------------------------
// aeNetReplicaClient class
//------------------------------------------------------------------------------
class aeNetReplicaClient
{
public:
  // The following sequence should be performed each frame
  void ReceiveData( const uint8_t* data, uint32_t length ); // 1) Handle raw data from server (call once when new data arrives)
  aeRef< aeNetData > PumpCreated(); // 2) Get new objects (call this repeatedly until no new NetDatas are returned)
  // 3) Handle new sync data with aeNetData::GetSyncData() and process incoming messages with aeNetData::PumpMessages()
  void DestroyPending(); // 4) Destroy all objects flagged for destruction (call once)

private:
  void m_CreateNetData( aeBinaryStream* rStream );
  aeMap< aeId< aeNetData >, aeNetData* > m_netDatas;
  aeMap< uint32_t, aeId< aeNetData > > m_remoteToLocalIdMap;
  aeArray< aeRef< aeNetData > > m_created;
  aeArray< aeRef< aeNetData > > m_destroyed;
};

//------------------------------------------------------------------------------
// aeNetReplicaServer class
//------------------------------------------------------------------------------
class aeNetReplicaServer
{
public:
  const uint8_t* GetSendData() const; // Call aeNetReplicaDB::UpdateSendData() first
  uint32_t GetSendLength() const; // Call aeNetReplicaDB::UpdateSendData() first

public:
  void m_UpdateSendData();

  bool m_first = true;
  class aeNetReplicaDB* m_replicaDB = nullptr;
  bool m_pendingClear = false;
  aeArray< uint8_t > m_sendData;
  // Internal
  enum class EventType : uint8_t
  {
    Connect,
    Create,
    Destroy,
    Update,
    Messages
  };
};

//------------------------------------------------------------------------------
// aeNetReplicaDB class
//------------------------------------------------------------------------------
class aeNetReplicaDB
{
public:
  aeNetData* CreateNetData( const uint8_t* initData, uint32_t initDataLength );
  void DestroyNetData( aeNetData* netData );

  aeNetReplicaServer* CreateServer();
  void DestroyServer( aeNetReplicaServer* server );

  void UpdateSendData(); // Call each frame before aeNetReplicaServer::GetSendData()

private:
  aeMap< aeId< aeNetData >, aeNetData* > m_netDatas;
  aeArray< aeNetReplicaServer* > m_servers;
public:
  // Internal
  aeNetData* GetNetData( uint32_t index ) { return m_netDatas.GetValue( index ); }
  uint32_t GetNetDataCount() const { return m_netDatas.Length(); }
};

// //------------------------------------------------------------------------------
// // Net structs
// //------------------------------------------------------------------------------
// struct NetPlayer
// {
//   uint8_t uuid[ 16 ];
// };

// struct NetInstInfo
// {
//   GameObjId gameId;
//   struct Game* game;
//   NetInstId netId;
//   aeMetaTypeId type;
//   bool levelObject;
// };

// struct Net
// {
//   double lastSendTime;
  
//   NetInstInfo netInsts[ kMaxNetInst ];
//   uint32_t netInstCount;

//   MsgObject messages[ kMaxNetMessages ];
//   uint32_t messageCount;
// };

// //------------------------------------------------------------------------------
// // Net Public Functions
// //------------------------------------------------------------------------------
// Net* Net_New();
// void Net_Delete( Net* );
// void Net_UpdateServer( struct Net* net, struct AetherServer* aether, struct Game* games, uint32_t count );
// void Net_UpdateClient( struct Net* net, struct AetherClient* aether, struct Game* game );
// void Net_RemoveObject( GameObject* go );
// GameObject* Net_GetGameObject( Net* net, Game* game, NetInstId id );
// GameObject* Net_GetGameObject( Net* net, Game* game, NetInstInfo info );
// AetherPlayer* Net_GetPlayer( Net* net, AetherServer* aether, NetInstId id );
// bool Net_CanChangeLevel( Net* net, struct AetherServer* aether, struct Player* player, const char* level );
// bool Net_PlayerChangeLevel( Net* net, struct AetherServer* aether, struct Player* player, const char* level, const char* link );

// void Net_SendObjectMessage( struct Net* net, struct AetherServer* aether, void* group, NetInstId id, uint8_t type, const uint8_t* data, uint32_t length );
// uint32_t Net_RecvObjectMessage( struct Net* net, NetInstId id, uint8_t* typeOut, uint8_t* dataOut );

// void Net_AddObject( Net* net, GameObject* go, bool levelObject );

// void Aether_SendRpc( struct AetherClient* aether, class Rpc* rpc );

//------------------------------------------------------------------------------
// Client / server constants
//------------------------------------------------------------------------------
typedef uint32_t NetInstId;
typedef uint16_t AetherMsgId;
const AetherMsgId kInvalidAetherMsgId = 0;
const AetherMsgId kSysMsgMask = 1 << ( sizeof(AetherMsgId) * 8 - 1 );
const AetherMsgId kSysMsgServerConnect = 1 | kSysMsgMask;
const AetherMsgId kSysMsgServerDisconnect = 2 | kSysMsgMask;
const AetherMsgId kSysMsgPlayerConnect = 3 | kSysMsgMask;
const AetherMsgId kSysMsgPlayerDisconnect = 4 | kSysMsgMask;

struct AetherAddress
{
  char host[ 32 ];
  uint16_t port;
};

struct ReceiveInfo
{
  AetherMsgId msgId = kInvalidAetherMsgId;
  aeArray< uint8_t > data;
};

struct SendInfo
{
  AetherMsgId msgId = kInvalidAetherMsgId;
  const void* data = nullptr;
  int32_t length = 0;
  bool reliable = false;
};

//------------------------------------------------------------------------------
// Aether Player
//------------------------------------------------------------------------------
struct AetherPlayer
{
  AetherUuid uuid;
  NetInstId netId;
  void* userData;
  bool alive;

  aeStr32 pendingLevel;
  aeStr32 pendingLink;
  bool hasPendingLevelChange;
};

//------------------------------------------------------------------------------
// Aether Client
//------------------------------------------------------------------------------
struct AetherClient
{
  AetherPlayer* localPlayer;
  aeArray< AetherPlayer* > allPlayers; // @TODO: Shouldn't expose players directly, since they can disconnect and become invalid
  
  AetherAddress serverAddress;
  bool isConnected;

  bool IsConnected() { return isConnected; }
  bool IsConnecting() { return m_isConnecting; }

  bool m_isConnecting;
};

AetherClient* AetherClient_New( AetherUuid uuid, const char* ip, uint16_t port );
void AetherClient_Delete( AetherClient* );

void AetherClient_Connect( AetherClient* _ac );
bool AetherClient_Receive( AetherClient*, ReceiveInfo* infoOut );
void AetherClient_SendAll( AetherClient* );
void AetherClient_QueueSend( AetherClient* ac, AetherMsgId msgId, bool reliable, const void* data, uint32_t length );

//------------------------------------------------------------------------------
// Aether Server
//------------------------------------------------------------------------------
struct ServerReceiveInfo
{
  AetherMsgId msgId = kInvalidAetherMsgId;
  aeArray< uint8_t > data;
  AetherPlayer* player = nullptr;
};

struct ServerSendInfo
{
  AetherMsgId msgId = kInvalidAetherMsgId;
  bool reliable = true;
  
  AetherPlayer* player = nullptr;
  void* group = nullptr;
  AetherPlayer* playerFilter = nullptr;
  void* groupFilter = nullptr;

  int32_t length = 0;
  const void* data = nullptr;
};

struct AetherServer
{
  AetherPlayer** allPlayers;
  int32_t playerCount;
};

AetherServer* AetherServer_New( uint16_t port, uint16_t webPort, uint32_t maxPlayers );
void AetherServer_Delete( AetherServer* );
void AetherServer_Update( AetherServer* );

bool AetherServer_Receive( AetherServer*, ServerReceiveInfo* infoOut );
void AetherServer_SendAll( AetherServer* );

AetherPlayer* AetherServer_GetPlayerByNetInstId( AetherServer*, NetInstId id );
uint32_t AetherServer_GetPlayerByUserData( AetherServer* as, const void* userData, AetherPlayer* (&playersOut)[ 32 ] );

void AetherServer_QueueSend( AetherServer* as, const ServerSendInfo* info );
void AetherServer_QueueBroadcast( AetherServer* as, AetherMsgId msgId, bool reliable, const void* data, uint32_t length );
void AetherServer_QueueSendToPlayer( AetherServer* as, AetherPlayer* player, AetherMsgId msgId, bool reliable, const void* data, uint32_t length );
void AetherServer_QueueSendToGroup( AetherServer* as, void* group, AetherMsgId msgId, bool reliable, const void* data, uint32_t length );

//------------------------------------------------------------------------------
// Aether Internal
//------------------------------------------------------------------------------
struct AetherServerHeader
{
  AetherMsgId msgId;
};

struct AetherClientHeader
{
  AetherMsgId msgId;
  AetherUuid uuid;
};

struct AetherMsgConnect
{
  AetherUuid uuid;
};

const int32_t kNetChannelReliable = 0;
const int32_t kNetChannelUnreliable = 1;

#endif
//------------------------------------------------------------------------------
// aeObjectPool.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEOBJECTPOOL_H
#define AEOBJECTPOOL_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeObjectPool class
//------------------------------------------------------------------------------
template< typename T, uint32_t N >
class aeObjectPool
{  
public:
  aeObjectPool()
  {
    m_length = 0;

    for ( uint32_t i = 0; i < N - 1; i++ )
    {
      m_pool[ i ].next = &m_pool[ i + 1 ];
      m_pool[ i ].allocated = false;
    }
    m_pool[ N - 1 ].next = nullptr;
    m_pool[ N - 1 ].allocated = false;
    
    m_open = &m_pool[ 0 ];
  }

  ~aeObjectPool()
  {
    for ( uint32_t i = 0; i < N; i++ )
    {
      Entry* entry = &m_pool[ i ];
      if ( entry->allocated )
      {
        T* object = (T*)entry->object;
        object->~T();
        entry->next = nullptr;
        entry->allocated = false;
      }
    }
    m_open = nullptr;
  }

  T* Allocate()
  {
    if ( !m_open )
    {
      return nullptr;
    }

    Entry* entry = m_open;
    m_open = m_open->next;
    entry->next = nullptr;
    entry->allocated = true;

    m_length++;

    return new( (T*)entry->object ) T();
  }

  void Free( T* p )
  {
    if ( !p )
    {
      return;
    }

    Entry* entry = m_GetEntry( p );
    p->~T();
    AE_ASSERT( entry->check == 0xCDCDCDCD );
    entry->next = m_open;
    entry->allocated = false;
    m_open = entry;

    m_length--;
  }

  const T* GetFirst() const
  {
    const Entry* entry = &m_pool[ 0 ];
    const T* p = (const T*)entry->object;
    return entry->allocated ? p : GetNext( p );
  }

  const T* GetNext( const T* p ) const
  {
    const Entry* entry = m_GetEntry( p );
    for ( uint32_t i = entry - m_pool + 1; i < N; i++ )
    {
      if ( m_pool[ i ].allocated )
      {
        return (const T*)m_pool[ i ].object;
      }
    }

    return nullptr;
  }

  T* GetFirst()
  {
    return const_cast< T* >( const_cast< const aeObjectPool< T, N >* >( this )->GetFirst() );
  }

  T* GetNext( T* p )
  {
    return const_cast< T* >( const_cast< const aeObjectPool< T, N >* >( this )->GetNext( p ) );
  }

  bool HasFree() const { return m_open != nullptr; }
  uint32_t Length() const { return m_length; }

private:
  struct Entry
  {
    Entry* next;
    bool allocated;
    uint32_t check = 0xCDCDCDCD;
    alignas(T) uint8_t object[ sizeof(T) ];
  };

  const Entry* m_GetEntry( const T* p ) const
  {
    Entry* entry = (Entry*)( (uint8_t*)p - offsetof( Entry, object ) );
    AE_ASSERT_MSG( m_pool <= entry && entry < m_pool + N, "Object is not in pool" );
    AE_ASSERT( entry->check == 0xCDCDCDCD );
    return entry;
  }

  Entry* m_GetEntry( T* p )
  {
    return const_cast< Entry* >( const_cast< const aeObjectPool< T, N >* >( this )->m_GetEntry( p ) );
  }

  uint32_t m_length;
  Entry* m_open;
  Entry m_pool[ N ];
};

#endif
//------------------------------------------------------------------------------
// aeRingBuffer.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AERINGBUFFER_H
#define AERINGBUFFER_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeRingBuffer class
//------------------------------------------------------------------------------
template < typename T, uint32_t N >
class aeRingBuffer
{
public:
  aeRingBuffer();
  void Append( const T& val );
  void Clear();

  const T& Get( uint32_t index ) const;
  uint32_t Length() const { return m_count; }
  uint32_t Size() const { return N; }

private:
  uint32_t m_first;
  uint32_t m_count;
  aeArray< T > m_buffer;
};

//------------------------------------------------------------------------------
// aeRingBuffer member functions
//------------------------------------------------------------------------------
template < typename T, uint32_t N >
aeRingBuffer< T, N >::aeRingBuffer() :
  m_first( 0 ),
  m_count( 0 ),
  m_buffer( N, T() ) // @TODO: Should not construct object until PushBack
{}

template < typename T, uint32_t N >
void aeRingBuffer< T, N >::Append( const T& val )
{
  m_buffer[ ( m_first + m_count ) % N ] = val;
  if ( m_count < N )
  {
    m_count++;
  }
  else
  {
    m_first++;
  }
}

template < typename T, uint32_t N >
void aeRingBuffer< T, N >::Clear()
{
  m_first = 0;
  m_count = 0;
}

template < typename T, uint32_t N >
const T& aeRingBuffer< T, N >::Get( uint32_t index ) const
{
  AE_ASSERT( index < m_count );
  return m_buffer[ ( m_first + index ) % N ];
}

#endif
//------------------------------------------------------------------------------
// aeSpline.h
// Utilities for allocating objects. Provides functionality to track current and
// past allocations.
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AESPLINE_H
#define AESPLINE_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeSpline class
//------------------------------------------------------------------------------
class aeSpline
{
public:
  aeSpline() = default;
  aeSpline( aeFloat3* controlPoints, uint32_t count );

  void AppendControlPoint( aeFloat3 p );
  void RemoveControlPoint( uint32_t index );
  void SetLooping( bool enabled );

  aeFloat3 GetControlPoint( uint32_t index ) const;
  uint32_t GetControlPointCount() const;

  aeFloat3 GetPoint( float distance ) const; // 0 <= distance <= length
  float GetMinDistance( aeFloat3 p, aeFloat3* nearestOut = nullptr );
  float GetLength() const;

  aeAABB GetAABB() const { return m_aabb; }

private:
  class Segment
  {
  public:
    void Init( aeFloat3 p0, aeFloat3 p1, aeFloat3 p2, aeFloat3 p3 );
    aeFloat3 GetPoint01( float t ) const;
    aeFloat3 GetPoint0() const;
    aeFloat3 GetPoint1() const;
    aeFloat3 GetPoint( float d ) const;
    float GetMinDistance( aeFloat3 p, aeFloat3* pOut ) const;
    float GetLength() const { return m_length; }
    aeAABB GetAABB() const { return m_aabb; }

  private:
    aeFloat3 m_a;
    aeFloat3 m_b;
    aeFloat3 m_c;
    aeFloat3 m_d;
    float m_length;
    uint32_t m_resolution;
    aeAABB m_aabb;
  };

  void m_RecalculateSegments();
  aeFloat3 m_GetControlPoint( int32_t index ) const;

  bool m_loop = false;
  aeArray< aeFloat3 > m_controlPoints;
  aeArray< Segment > m_segments;
  float m_length = 0.0f;
  aeAABB m_aabb;
};

#endif
//------------------------------------------------------------------------------
// aeTerrain.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AETERRAIN_H
#define AETERRAIN_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------
#include <atomic>

namespace ctpl
{
  class thread_pool;
}

//------------------------------------------------------------------------------
// aeUnit
//------------------------------------------------------------------------------
template < typename T >
class aeUnit
{
public:
  aeUnit() : m_v() { AE_STATIC_ASSERT( sizeof(*this) == sizeof(T) ); }
  aeUnit( const aeUnit& o ) : m_v( o.m_v ) {}
  explicit aeUnit( const T& vertexCount ) : m_v( vertexCount ) {}

  template < typename U >
  explicit operator U () const { return (U)m_v; }

  bool operator == ( const aeUnit& o ) const { return m_v == o.m_v; }
  bool operator != ( const aeUnit& o ) const { return m_v != o.m_v; }
  bool operator < ( const aeUnit& o ) const { return m_v < o.m_v; }
  bool operator > ( const aeUnit& o ) const { return m_v > o.m_v; }
  bool operator <= ( const aeUnit& o ) const { return m_v <= o.m_v; }
  bool operator >= ( const aeUnit& o ) const { return m_v >= o.m_v; }
  
  aeUnit< T > operator + ( const aeUnit& v ) const { return aeUnit( m_v + v.m_v ); }
  aeUnit< T > operator - ( const aeUnit& v ) const { return aeUnit( m_v - v.m_v ); }
  aeUnit< T >& operator ++ () { m_v++; return *this; }
  aeUnit< T >& operator -- () { m_v--; return *this; }
  aeUnit< T > operator ++ ( int ) { aeUnit< T > temp = *this; ++*this; return temp; }
  aeUnit< T > operator -- ( int ) { aeUnit< T > temp = *this; --*this; return temp; }
  aeUnit< T >& operator += ( const T& v ) { m_v += v; return *this; }
  aeUnit< T >& operator -= ( const T& v ) { m_v -= v; return *this; }

private:
  operator bool () const = delete;
  T m_v;
};

template < typename T >
inline std::ostream& operator<<( std::ostream& os, const aeUnit< T >& u )
{
  return os << (T)u;
}

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------
typedef aeUnit< uint32_t > VertexCount;
typedef float float16_t;
typedef uint8_t aeTerrainMaterialId;
#define PACK( _ae_something ) _ae_something

const uint32_t kChunkSize = 32; // 32*32*32 is less than max vertex index
const int32_t kTempChunkSize = kChunkSize + 2; // Include a 1 voxel border
const int32_t kTempChunkSize3 = kTempChunkSize * kTempChunkSize * kTempChunkSize; // Temp voxel count
const uint32_t kMaxActiveChunks = 1024;
const uint32_t kMaxLoadedChunks = kMaxActiveChunks * 2;
const VertexCount kMaxChunkVerts = VertexCount( kChunkSize * kChunkSize * kChunkSize );
const uint32_t kMaxChunkIndices = kChunkSize * kChunkSize * kChunkSize * 6;
const uint32_t kMaxChunkAllocationsPerTick = 1;
const float16_t kSkyBrightness = float16_t( 5.0f );
const float kSdfBoundary = 2.0f;

struct Block
{
  enum Type : uint8_t
  {
    Exterior,
    Interior,
    Surface,
    Blocking,
    Unloaded,
    COUNT
  };
};

//------------------------------------------------------------------------------
// TerrainVertex
//------------------------------------------------------------------------------
PACK( struct TerrainVertex
{
  aeFloat3 position;
  aeFloat3 normal;
  uint8_t materials[ 4 ];
  uint8_t info[ 4 ];
});
typedef uint16_t TerrainIndex;
const TerrainIndex kInvalidTerrainIndex = ~0;
const VertexCount kChunkCountInterior = VertexCount( ~0 - 1 ); // Whole chunk is solid. Used for raycasting
const VertexCount kChunkCountDirty = VertexCount( ~0 ); // Flags chunks that should be (re)generated
const VertexCount kChunkCountEmpty = VertexCount( 0 );

struct RaycastResult
{
  bool hit;
  Block::Type type;
  float distance;
  aeInt3 posi; // @NOTE: It's possible for the intersection to end up outside the original voxel
  aeFloat3 posf;
  aeFloat3 normal;
  bool touchedUnloaded;
};

struct EdgeCompact
{
  uint8_t f;
  int8_t nx;
  int8_t ny;
  int8_t nz;
};

float aeUnion( float d1, float d2 );
float aeSubtraction( float d1, float d2 );
float aeIntersection( float d1, float d2 );
float aeSmoothUnion( float d1, float d2, float k );
float aeSmoothSubtraction( float d1, float d2, float k );

//------------------------------------------------------------------------------
// ae::Sdf
//------------------------------------------------------------------------------
namespace ae { namespace Sdf {

//------------------------------------------------------------------------------
// Shape class
//------------------------------------------------------------------------------
class Shape
{
public:
  Shape();
  virtual ~Shape() {}

  aeAABB GetAABB() const { return m_aabb; }
  aeOBB GetOBB() const { return aeOBB( m_localToWorld ); }
  
  void SetTransform( const aeFloat4x4& transform );
  const aeFloat4x4& GetTransform() const { return m_localToWorld; }
  aeFloat3 GetHalfSize() const { return m_halfSize; }

  void Dirty() { m_dirty = true; } // Must be be explicitly called if object is modified after creation

  virtual float GetValue( aeFloat3 p ) const = 0;

  enum class Type
  {
    Union,
    Subtraction,
    SmoothUnion,
    SmoothSubtraction,
    Material
  };
  Type type = Type::Union;
  aeTerrainMaterialId materialId = 0;
  float smoothing = 0.0f; // Works with SmoothUnion and SmoothSubtraction types

protected:
  const aeFloat4x4& GetWorldToScaled() const { return m_worldToScaled; }

private:
  aeAABB m_aabb;
  aeFloat3 m_halfSize;
  aeFloat4x4 m_localToWorld;
  aeFloat4x4 m_worldToScaled;

public:
  // Internal
  bool m_dirty = false;
  aeAABB m_aabbPrev;
};

//------------------------------------------------------------------------------
// Box class
//------------------------------------------------------------------------------
class Box : public Shape
{
public:
  float GetValue( aeFloat3 p ) const override;

  float cornerRadius = 0.0f;
};

//------------------------------------------------------------------------------
// Cylinder class
//------------------------------------------------------------------------------
class Cylinder : public Shape
{
public:
  float GetValue( aeFloat3 p ) const override;

  // Valid range is 0-1, are multiplied by obb size
  float top = 1.0f;
	float bottom = 1.0f;
};

//------------------------------------------------------------------------------
// Heightmap class
//------------------------------------------------------------------------------
class Heightmap : public Shape
{
public:
  void SetImage( ae::Image* heightMap ) { m_heightMap = heightMap; }
  float GetValue( aeFloat3 p ) const override;

private:
  ae::Image* m_heightMap = nullptr;
};

} } // ae::Sdf

//------------------------------------------------------------------------------
// aeTerrainSDF class
//------------------------------------------------------------------------------
class aeTerrainSDF
{
public:
  aeTerrainSDF( class aeTerrain* terrain );

  template < typename T >
  T* CreateSdf();
  void DestroySdf( ae::Sdf::Shape* sdf );

  void UpdatePending();
  bool HasPending() const;
  void RenderDebug( aeDebugRender* debug );

  // @NOTE: This will be called from multiple threads simultaneously and so must be const
  float GetValue( aeFloat3 pos ) const;
  aeFloat3 GetDerivative( aeFloat3 pos ) const;
  aeTerrainMaterialId GetMaterial( aeFloat3 pos ) const;

private:
  friend class aeTerrain;

  class aeTerrain* m_terrain;
  aeArray< ae::Sdf::Shape* > m_shapes;
  aeArray< ae::Sdf::Shape* > m_shapesPrev;
  aeArray< ae::Sdf::Shape* > m_pendingCreated;
  aeArray< ae::Sdf::Shape* > m_pendingDestroy;

  // Internal use by aeTerrain
  uint32_t GetShapeCount() const { return m_shapes.Length(); }
  ae::Sdf::Shape* GetShapeAtIndex( uint32_t index ) const { return m_shapes[ index ]; }
};

template < typename T >
T* aeTerrainSDF::CreateSdf()
{
  ae::Sdf::Shape* sdf = aeAlloc::Allocate< T >();
  m_pendingCreated.Append( sdf );
  return static_cast< T* >( sdf );
}

//------------------------------------------------------------------------------
// aeTerrainSDFCache class
//------------------------------------------------------------------------------
class aeTerrainSDFCache
{
public:
  aeTerrainSDFCache();
  ~aeTerrainSDFCache();

  void Generate( aeInt3 chunk, const aeTerrainSDF* sdf );
  float GetValue( aeFloat3 pos ) const;
  float GetValue( aeInt3 pos ) const;
  aeFloat3 GetDerivative( aeFloat3 p ) const;
  uint8_t GetMaterial( aeFloat3 pos ) const;

private:
  float m_GetValue( aeInt3 pos ) const;

  const aeTerrainSDF* m_sdf;

  const int32_t kDim = kChunkSize + 5; // TODO: What should this value actually be? Corresponds to chunkPlus
  static const int32_t kOffset = 2;
  
  aeInt3 m_chunk;
  aeInt3 m_offseti; // Pre-computed chunk integer offset
  aeFloat3 m_offsetf; // Pre-computed chunk float offset

  float16_t* m_values;
};

//------------------------------------------------------------------------------
// aeTerrainJob class
//------------------------------------------------------------------------------
class aeTerrainJob
{
public:
  aeTerrainJob();
  ~aeTerrainJob();
  void StartNew( const aeTerrainSDF* sdf, struct aeTerrainChunk* chunk );
  void Do();
  void Finish();

  bool HasJob() const { return m_hasJob; }
  bool HasChunk( aeInt3 pos ) const;
  bool IsPendingFinish() const { return m_hasJob && !m_running; }

  const aeTerrainChunk* GetChunk() const { return m_chunk; }
  aeTerrainChunk* GetChunk() { return m_chunk; }
  const TerrainVertex* GetVertices() const { return m_vertices.Length() ? &m_vertices[ 0 ] : nullptr; }
  const TerrainIndex* GetIndices() const { return m_indexCount ? &m_indices[ 0 ] : nullptr; }
  VertexCount GetVertexCount() const { return m_vertexCount; }
  uint32_t GetIndexCount() const { return m_indexCount; }

private:
  // Management
  bool m_hasJob;
  std::atomic_bool m_running;

  // Input
  const aeTerrainSDF* m_sdf;
  struct aeTerrainChunk* m_chunk;

  // Pre-computed sdf
  aeTerrainSDFCache m_sdfCache;

  // Output
  VertexCount m_vertexCount;
  uint32_t m_indexCount;
  aeArray< TerrainVertex > m_vertices;
  aeArray< TerrainIndex > m_indices;

public:
  // Temp edges (pre-allocate edges for all future jobs)
  struct TempEdges
  {
    int32_t x;
    int32_t y;
    int32_t z;
    uint16_t b;

    // 3 planes whose intersections are used to position vertices within voxel
    // EDGE_TOP_FRONT_BIT
    // EDGE_TOP_RIGHT_BIT
    // EDGE_SIDE_FRONTRIGHT_BIT
    aeFloat3 p[ 3 ];
    aeFloat3 n[ 3 ];
  };

  TempEdges* edgeInfo;
};

//------------------------------------------------------------------------------
// Terrain Chunk class
//------------------------------------------------------------------------------
struct aeTerrainChunk
{
  aeTerrainChunk();
  ~aeTerrainChunk();

  static uint32_t GetIndex( aeInt3 pos );
  static void GetPosFromWorld( aeInt3 pos, aeInt3* chunkPos, aeInt3* localPos );

  uint32_t GetIndex() const;
  void Generate( const aeTerrainSDFCache* sdf, aeTerrainJob::TempEdges* edgeBuffer, TerrainVertex* verticesOut, TerrainIndex* indexOut, VertexCount* vertexCountOut, uint32_t* indexCountOut );

  aeAABB GetAABB() const;
  static aeAABB GetAABB( aeInt3 chunkPos );

  uint32_t m_check;
  aeInt3 m_pos;
  bool m_geoDirty;
  bool m_lightDirty;
  aeVertexData m_data;
  TerrainVertex* m_vertices;
  aeListNode< aeTerrainChunk > m_generatedList;
  
  Block::Type m_t[ kChunkSize ][ kChunkSize ][ kChunkSize ];
  float16_t m_l[ kChunkSize ][ kChunkSize ][ kChunkSize ];
  TerrainIndex m_i[ kChunkSize ][ kChunkSize ][ kChunkSize ];

private:
  static void m_GetQuadVertexOffsetsFromEdge( uint32_t edgeBit, int32_t( &offsets )[ 4 ][ 3 ] );
};

//------------------------------------------------------------------------------
// aeTerrain class
//------------------------------------------------------------------------------
class aeTerrain
{
public:
  aeTerrain();
  ~aeTerrain();

  void Initialize( uint32_t maxThreads, bool render );
  void Terminate();
  void Update( aeFloat3 center, float radius );
  void Render( const class aeShader* shader, const aeUniformList& shaderParams );
  void SetDebug( class aeDebugRender* debug );

  void SetDebugTextCallback( std::function< void( aeFloat3, const char* ) > fn ) { m_debugTextFn = fn; }
  uint32_t GetMaxThreads() const { return m_terrainJobs.Length(); }
  
  Block::Type GetVoxel( int32_t x, int32_t y, int32_t z ) const;
  Block::Type GetVoxel( aeFloat3 position ) const;
  bool GetCollision( int32_t x, int32_t y, int32_t z ) const;
  bool GetCollision( aeFloat3 position ) const;
  float16_t GetLight( int32_t x, int32_t y, int32_t z ) const;

  aeTerrainChunk* GetChunk( uint32_t chunkIndex );
  aeTerrainChunk* GetChunk( aeInt3 pos );
  const aeTerrainChunk* GetChunk( uint32_t chunkIndex ) const;
  const aeTerrainChunk* GetChunk( aeInt3 pos ) const;
  VertexCount GetVertexCount( uint32_t chunkIndex ) const;
  VertexCount GetVertexCount( aeInt3 pos ) const;

  bool VoxelRaycast( aeFloat3 start, aeFloat3 ray, int32_t minSteps ) const;
  RaycastResult RaycastFast( aeFloat3 start, aeFloat3 ray, bool allowSourceCollision ) const;
  RaycastResult Raycast( aeFloat3 start, aeFloat3 ray ) const;
  // @NOTE: SweepSphere returns true on collision and writes out the following:
  // distanceOut is distance traveled before collision
  // normalOut is ground normal
  // posOut is ground collision point
  bool SweepSphere( aeSphere sphere, aeFloat3 ray, float* distanceOut = nullptr, aeFloat3* normalOut = nullptr, aeFloat3* posOut = nullptr ) const;
  bool PushOutSphere( aeSphere sphere, aeFloat3* offsetOut = nullptr, class aeDebugRender* debug = nullptr ) const;
  
  aeTerrainSDF sdf;

private:
  const TerrainVertex* m_GetVertex( int32_t x, int32_t y, int32_t z ) const;
  void UpdateChunkLighting( aeTerrainChunk* chunk );
  
  aeTerrainChunk* AllocChunk( aeInt3 pos );
  void FreeChunk( aeTerrainChunk* chunk );
  void m_SetVertexCount( uint32_t chunkIndex, VertexCount count );
  float GetChunkScore( aeInt3 pos ) const;

  aeDebugRender* m_debug = nullptr;

  bool m_render = false;
  aeFloat3 m_center = aeFloat3( 0.0f );
  float m_radius = 0.0f;
  
  //aeCompactingAllocator m_compactAlloc;
  std::map< uint32_t, struct aeTerrainChunk* > m_chunks3;
  std::map< uint32_t, VertexCount > m_vertexCounts; // Kept even when chunks are freed so they are not regenerated again if they are empty
  //aeMap<>
  aeObjectPool< aeTerrainChunk, kMaxLoadedChunks > m_chunkPool;

  // Keep these across frames instead of allocating temporary space for each generated chunk
  struct ChunkSort
  {
    aeTerrainChunk* c;
    aeInt3 pos;
    float score;
  };
  //aeMap< aeInt3, ChunkSort > t_chunkMap;
  std::map< uint32_t, ChunkSort > t_chunkMap_hack;
  aeArray< ChunkSort > t_chunkSorts;

  aeList< aeTerrainChunk > m_generatedList;
  
  bool m_blockCollision[ Block::COUNT ];
  float16_t m_blockDensity[ Block::COUNT ];
  
  ctpl::thread_pool* m_threadPool = nullptr;
  aeArray< aeTerrainJob* > m_terrainJobs;

  std::function< void( aeFloat3, const char* ) > m_debugTextFn;

public:
  // Internal
  void m_Dirty( aeAABB aabb );
};

#endif
//------------------------------------------------------------------------------
// aeTesting.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AE_TESTING_H
#define AE_TESTING_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------
namespace AE_NAMESPACE {

//------------------------------------------------------------------------------
// LifeTimeTester class
//------------------------------------------------------------------------------
class LifetimeTester
{
public:
  LifetimeTester(); // default
  LifetimeTester( const LifetimeTester& ); // copy
  LifetimeTester( LifetimeTester&& ) noexcept; // move
  LifetimeTester& operator=( const LifetimeTester& ); // copy assignment
  LifetimeTester& operator=( LifetimeTester&& ) noexcept; // move assignment
  ~LifetimeTester();
  
  static const uint32_t kConstructed;
  static const uint32_t kMoved;
  
  uint32_t check;
  
  static void ClearStats();
  
  static int32_t ctorCount;
  static int32_t copyCount;
  static int32_t moveCount;
  static int32_t copyAssignCount;
  static int32_t moveAssignCount;
  static int32_t dtorCount;
  static int32_t currentCount;
};

} // ae namespace end

#endif
/*
The MIT License (MIT)

Copyright (c) 2014 Graeme Hill (http://graemehill.ca)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#pragma once

#ifdef __linux__
#define GUID_LIBUUID
#endif

#ifdef __APPLE__
#define GUID_CFUUID
#endif

#ifdef _MSC_VER
#define GUID_WINDOWS
#endif

#ifdef __EMSCRIPTEN__
#define GUID_LIBUUID
#endif

#ifdef GUID_ANDROID
#include <jni.h>
#endif

typedef class Guid aeUuid;
typedef class GuidGenerator aeUuidGenerator;

// Class to represent a GUID/UUID. Each instance acts as a wrapper around a
// 16 byte value that can be passed around by value. It also supports
// conversion to string (via the stream operator <<) and conversion from a
// string via constructor.
class Guid
{
  public:

    // create a guid from vector of bytes
    Guid(const std::vector<unsigned char> &bytes);

    // create a guid from array of bytes
    Guid(const unsigned char *bytes);

    // create a guid from string
    Guid(const std::string &fromString);

    // create empty guid
    Guid();

    // copy constructor
    Guid(const Guid &other);

    // overload assignment operator
    Guid &operator=(const Guid &other);

    // overload equality and inequality operator
    bool operator==(const Guid &other) const;
    bool operator!=(const Guid &other) const;
    
    // actual data
    std::vector<unsigned char> _bytes;

    // make the << operator a friend so it can access _bytes
    friend std::ostream &operator<<(std::ostream &s, const Guid &guid);
};

// Class that can create new guids. The only reason this exists instead of
// just a global "newGuid" function is because some platforms will require
// that there is some attached context. In the case of android, we need to
// know what JNIEnv is being used to call back to Java, but the newGuid()
// function would no longer be cross-platform if we parameterized the android
// version. Instead, construction of the GuidGenerator may be different on
// each platform, but the use of newGuid is uniform.
class GuidGenerator
{
  public:
#ifdef GUID_ANDROID
    GuidGenerator(JNIEnv *env);
#else
    GuidGenerator() { }
#endif

    Guid newGuid();

#ifdef GUID_ANDROID
  private:
    JNIEnv *_env;
    jclass _uuidClass;
    jmethodID _newGuidMethod;
    jmethodID _mostSignificantBitsMethod;
    jmethodID _leastSignificantBitsMethod;
#endif
};
//------------------------------------------------------------------------------
// aeString.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEVFS_H
#define AEVFS_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// aeVfs class
//------------------------------------------------------------------------------
class aeVfs
{
public:
  enum Root { Data, User };

  void Initialize( const char* dataDir, const char* organizationName, const char* applicationName );

  uint32_t GetSize( Root root, const char* fileName );
  uint32_t Read( Root root, const char* fileName, void* buffer, uint32_t bufferSize );
  uint32_t Write( Root root, const char* fileName, const void* buffer, uint32_t bufferSize );

  static uint32_t GetSize( const char* fileDir );
  static uint32_t Read( const char* fileDir, void* buffer, uint32_t bufferSize );
  static uint32_t Write( const char* fileDir, const void* buffer, uint32_t bufferSize );

  const char* GetRootDir( Root root );

private:
  aeStr256 m_dataDir;
  aeStr256 m_userDir;
};

#endif
//------------------------------------------------------------------------------
// aeWindow.h
//------------------------------------------------------------------------------
// Copyright (c) 2020 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AEWINDOW_H
#define AEWINDOW_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Window class
//------------------------------------------------------------------------------
class aeWindow
{
public:
  aeWindow();
  // @TODO: Init should take window title, since SetTitle is practically always called after Init()
  void Initialize( uint32_t width, uint32_t height, bool fullScreen, bool showCursor );
  void Initialize( aeInt2 pos, uint32_t width, uint32_t height, bool showCursor );
  void Terminate();

  void SetTitle( const char* title );
  void SetFullScreen( bool fullScreen );
  void SetPosition( aeInt2 pos );
  void SetSize( uint32_t width, uint32_t height );

  aeInt2 GetPosition() const { return m_pos; }
  int32_t GetWidth() const { return m_width; }
  int32_t GetHeight() const { return m_height; }
  bool GetFullScreen() const { return m_fullScreen; }

private:
  void m_Initialize();
    
  aeInt2 m_pos;
  int32_t m_width;
  int32_t m_height;
  bool m_fullScreen;

public:
  // Internal
  void m_UpdatePos( aeInt2 pos ) { m_pos = pos; }
  void m_UpdateWidthHeight( int32_t width, int32_t height ) { m_width = width; m_height = height; }

  void* window;
};

#endif
//------------------------------------------------------------------------------
// ae.h
//------------------------------------------------------------------------------
// Copyright (c) 2021 John Hughes
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files( the "Software" ), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//------------------------------------------------------------------------------
#ifndef AE_AE_H
#define AE_AE_H

//------------------------------------------------------------------------------
// Headers
//------------------------------------------------------------------------------

#endif
